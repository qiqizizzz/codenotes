# 一、程序设计ABC

## 1.字节问题

> char：一个字节
>
> short：两个字节

## 2.预处理命令

#define、#ifndef、#endif是预处理命令，它们一起用来根据不同情况编译代码、产生不同目标文件的机制，称为条件编译。一般可以用于**防止头文件重复包含**。



# 二、数据类型、运算符和表达式

## 1.枚举常量

```c
//定义一组枚举常量
enum colos{red,yellow,green};
//在函数头中的用法
void f(enum color c);//enum不能少！！！
int main(void)
{
enum color t=red;
scanf("%d",&t);
f(t);
}
void f(enum color c)
{
printf("%d",c);
}
```

实际上是以整数（int）来做内部计算和外部输入输出的。

> 上述例子中：
>
> red=0，yellow=1，green=2；
>
> 若有其他名字则以此类推
>
> 比如：我想输出red的%d值，那么编译器会给出的结果是red=0
>
> 同时，我们可以在定义一组枚举常量的同时，给不同的名字赋值.
>
> 比如：red=0，yellow=4，green=9；

如果有意义上的排比的名字，用枚举比const int方便，且枚举比宏（macro）好，因为枚举有int类型

## 2. 增1和减1运算符

后缀++和后缀--的优先级高于前缀++、前缀--和其他单目运算符。

> x++和++x相当于x=x+1

> x--和--x相当于x=x-1

> 但与其他变量一起使用的时候因为优先的不同会出现差异，如下表：(n=3)

| 语句   | 与左边语句等价的语句 | 执行该语句后m的值 | 执行该语句后n的值 |
| ------ | -------------------- | ----------------- | ----------------- |
| m=n++; | m=n; n=n+1;          | 3                 | 4                 |
| m=n--; | m=n; n=n-1;          | 3                 | 2                 |
| m=++n; | n=n+1;m=n;           | 4                 | 4                 |
| m=--n; | n=n-1;m=n;           | 2                 | 2                 |

## 3.const类型修饰符

```c
const 的含义是“只读的”，可以采用记录口诀，“左定值， 右定向”（const位于*左 指向的值不变，const位于*右侧，指针指向不可改变）。 
```

  ## 4.无符号类型

unsigned

无符号的数没有负数，永远**大于等于零**。



# 三、输入和输出

## 1.%d、%x、%o、%i

这些都是格式转换说明符。

> %d：十进制
>
> %x：十六进制
>
> %o：八进制
>
> %i：十六进制或八进制（根据用户输入系统自己判断的）



# 四、程序的控制结构

## 1.条件运算符

```c
表达式1？表达式2：表达式3
```

若表达式1的值为真（即非0），则该条件表达式的值是表达式2的值，否则是表达式3的值。

> 这是c语言中的唯一的一种三元运算符

## 2.逻辑操作符

```c
int x=3,y=3;
int t=++x || ++y;
//int t=++x || ++y;
```

 || 如果第一个是真后面就不运算了，&&如果前为假后面也不执行了

逻辑与 &&、逻辑或 || 均有“短路”特性:

逻辑与&&“短路”：当逻辑与&&的左操作数为逻辑 “假“ 时，就足以判断该逻辑运算的结果为假了，故右操作数就不再被执行。

逻辑或||“短路”：当逻辑或||的左操作数为逻辑 “真” 时，就足以判断该逻辑运算的结果为真了，故右操作数就不再被执行。

## 3.单目操作符

**sizeof**

> sizeof是C语言中的一个操作符(operator),不是函数调用,简单的说其作用就是返回一个对象或者类型所占的内存字节数由于结果是无符号整数,因此可以把它看作是无符号整型表达式。



# 五、函数

## 1.static、register、auto（变量的存储类型）

static

> 静态变量
>
> 作用范围:仅在语句块内有效，但其空间自第一次进入语句块时分配且初始化后，一直到程序完全退出才释放，所以其值始终保持。

register

> 寄存器变量
>
> 这是一个不再需要的关键字，编译器会自动优化程序。

auto

> 自动变量
>
> 到目前所学到的c语言知识为止，所有使用的局部变量都是自动变量，可以完全忽略。



# 六、数组

## 1.%c和%s

%c格式对应的是单个字符，%s格式对应的是字符串。

例：

```c
char a;
char b[20];
scanf("%c",&a);//只能输入一个字符
scanf("%s",b);//可以输入一串不超过20字符的字符串
```

注：

> 1.输入的时候scanf("%c",&a)；这里的&不能少，而scanf("%s",b)；这里不能有&符号.

> 2.%s只能用于字符串，不能用作整型数值int等的输入.

> 3.使用%s输入字符串时，输入结束后会自动给末尾加上一个'\0'.

> 4.printf和scanf函数中均可使用.

> 5.记住%s是遇到\0结束的就好了

> 6.指向字符串的指针，初始化赋值时，前面不需要加上取址运算符&
>
> ```c
> //假定s指向的字符串为“Hello World”
> //要使变量p指向s指向的字符串
> char *p=s;
> ```

字符串的输入的另一种方法：

```c
char awa[100];
fgets(awa,sizeof(awa),stdin);
```



理解误区：

```c
int b;
char c[10];
```

对于一个在栈上分配的数组，且在创建的代码块中进行访问的话 "c" 实际上有两种含义 : 

1. 一个指向十个char类型元素的数组
2.  一个char* 类型的指针 对于1而言 ，在同代码块中 sizeof(c) 输出 10，而不是4或者8 那么何时会是 1 何时 会是2呢？ 实际上 2是 1的一种语法糖，是语言设计者为了方便而放下的一个空子，大家可以尝试一下二维数组，这个语法糖就不成立了，因为作者没有留下这种语法糖给程序员。
3.  这就是所谓的上下文语义(编译器读的语义): scanf("%s", c); //这里c是一个char* 类型的指针，编译器相信程序员将它指向了一块内存块 scanf("%s", &c); //这里c是一个指向十个char元素的数组的指针，这种才是最正统的用法

## 2.\0的使用

\0是数组结束的证明，为了养成良好的代码风格，我们通常在给一个数组赋值后，在循环的后面加上它.

例如：

```c
int shuzu[10];
int i=0;
for(i=0;i<10;i++)
scanf("%d",&shuzu[i]);
//循环后i=10
shuzu[i]='\0';//这是必须要写的
```



注： 

i=10而不是i=0的原因：

i是在for循环外面定义的，是作用于整个main函数的值，首先取值为0，经循环后i=10，退出循环.

若

```c
for(int i=0;i<10;i++)
....
```

则这个i是仅仅作用于for循环里面的i，无法作用于整个main函数.

## 3.qwq[size]中size的实际取值

```c
char qwq[size]=“xiao";
/*qwq[0]='x';qwq[1]='i';
qwq[2]='a';qwq[3]='o';qwq[4]='\0';*/
```

此时的size＝5，因为xiao的长度为4，且末尾必须留一个位置给空字符‘\0'.

因此，size=数组中所有元素的总和

> 若事先未知size的值，则可以通过以下方式让用户给数组加入所输入的东西而不会报错.

```c
char arr[] = { };//中间是一个空格
gets(arr);
```

## 4.常用的字符串处理函数

| 函数功能     | 函数的一般形式                                               |
| ------------ | ------------------------------------------------------------ |
| 求字符串长度 | strlen(字符串)                                               |
| 字符串复制   | strcpy（字符数组1，字符串2）                                 |
| 字符串比较   | strcmp(字符串1，字符串2)  //前者最好写已知的字符串，后者写用户输入的字符串 |
| 字符串连接   | strcat(字符数组1，字符串2)                                   |

## 5.字符串和字符

```c
char *month[]={"January"};//定义字符串
char *number[]={'0'};//定义字符
```



> 定界符不同：字符使用单引号（‘ ’）作为定界符，而字符串是使用双引号（“ ”）作为定界符。2、占用的字节数不同：字符通常只占据一个字节，但是字符串可以占据多个字节。而且，在字符串的结尾处，自动被编译器加上了＇＼0＇这个字符，在ASCII码中，＇＼0＇表示的是一个空字符。

## 6.十大经典排序算法

**1.冒泡排序**

```c
char a[]={1,55,56,4,33};
int n=sizeof(a)/sizeof(a[0]);
int i,j,temp;
for(i=0;i<n-1;i++)
{
	for(j=0;j<n-i-1;j++)
	{
		if(a[j]>a[j+1])
		{
		temp=a[j];
		a[j]=a[j+1];
		a[j+1]=temp;
		}
	}
}
```

> 它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行，直到没有相邻元素需要交换，也就是说该元素列已经排序完成。
> 这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。

**2.选择排序**

```c
int arr[]=={13,43,1,43,3};
int i, j, k, tmp;
for (i = 0; i < size - 1; i++)
{
k = i;
for (j = i + 1; j < size; j++)
{
if (arr[j] < arr[k]) 
{
k = j;
}
}
tmp = arr[k];
arr[k] = arr[i];
arr[i] = tmp;
```

> 选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

**3.插入排序**

**4.希尔排序**

**5.归并排序**

**6.快速排序**

**7.基数排序**

**8.堆排序**

**9.计数排序**

**10.桶排序**



# 七、指针

## 1.如何给指针赋值

1.对于非数组来说：

```c
char *p1,*p2;//这时的指针没有指向，叫作“悬浮指针”
char a;
p1=&a;//获取了a的地址
p1=7;//实际上a也等于7
printf("%d",*p1);
printf("%d",p1);
```

> 指针赋值是间接赋值，不能直接给指针赋值，比如：int *p1=4，这样是错误的用法。

> printf("%d",*p1);
>
> *p1代表的是值（即7）.
>
> printf("%d",p1);
>
> p1代表的是p1的地址(不同的操作系统中地址不同）.

2.对于数组来说

```c
char *a;
char c[]={1,2};
a=c;//指针a指向了数组c的首地址
```

> 任何一个指针都需要初始化，否则会使程序错误！

## 2.多级指针

```c
	int a=10;
	int* p1;
	int** p2;
	int **p3;
	int*** p4;

	p1=&a;
	p2=&p1;
	p3=&p1;
	p4=&p2;
    //具体的值
    printf("*p1=%d\n",*p1);
    printf("p1=%d\n",p1);
    printf("*(*p2)=%d\n",*p2);
    printf("*(*p3)=%d\n",*p3);
    printf("*(*(*p4))=%d\n",*(*p4));
```

> 输出结果：
>
> *p1=10
>
> p1=6422028
>
> ....（同上）

能够实现在指针中存储一个指针的地址.

## 3.数组与指针

```c
//调用的函数
int SumOfElements(int *A,int size)
{
int i,sum=0;
for(i=0;i<size;i++)
sum+=A[i];
return sum;
}
//主函数
int main()
{
int A[]={1,2,3,4,5};
int size=sizeof（A）/sizeof(A[0]);
int total=SumOfElements(A,size);//传引用，数组相当于一个特殊的指针
}
```



> 传引用一个数组的首位的地址，即A[0]，实际上*A＝A[0]，这里的等于是建立在函数参数中的，只是解释为一个指针变量.
>
> 数组作为函数参数时被解释为一个指针，即A[]＝*A.
>
> 解引用相当于降维（若为三维数组，那一次解引用相当于将其变为了带有指针的二维数组）

概念知识：

传引用：传引用是指在函数调用时，将实际参数的引用（地址或指针）传递给形式参数。在函数内部，可以通过这个引用（指针）来修改实际参数的值。这种传递方式可以实现对实际参数的直接修改，而不需要通过返回值来传递修改后的结果。

解引用：是指使用指针来访问其所指向的变量的值。在C/C++等语言中，指针是一个变量，它存储了另一个变量的内存地址。通过使用“*”运算符来解引用指针，可以获取指针所指向的变量的值。解引用也可以用来修改所指向的变量的值，通过间接引用（dereferencing）操作，我们可以实现对指针所指向的变量的修改。

引用传递：所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。

总之，传引用和指针解引用是两种不同的概念，传引用关注的是函数参数传递的方式，而解引用则关注的是如何通过指针来访问其所指向的变量的值，并可能实现对变量的修改。

## 4.指针和二维数组

```c
int B[2][3];
//*B=B[0] or &B[0][0]
B=&B[0]
B+1=&B[0]+1=*B+1=&B[1]
*(B+1)=B[1] or&B[1][0]
*(B+1)+2=B[1]+2 or &B[1][2]
*(*B+1)=*(&B[0][0]+1)
=*(&B[0][1])=B[0][1]
```

> *和&是逆运算.
>
> *和+运算等级相同，故从左向右进行运算.

> *B=B[0]，在二维数组中
>
> *B表示为地址

## 5.多维数组

```c
c[i][j][k]=*(c[i][j]+k)=*(*(c[i]+j)+k)=*(*(*(c+i)+j)+k)
```

*个数 + []个数 = 数组维度(3);  * 和 [] 表示解一次引用; + k 表示跨度不解引用； 看*,[]总个数就行

> *的数量+[]的数量=x(x是数组的维度)

特别注意：

> 1.数组的第一个维度可以省略，但其余的维度需要指定

例如：

```c
char a[][3][3];
//后面两个维度必须有个size
```

## 6.函数与指针

```c
void awa(int *a,int *c);
int main()
{
	int *a=0;
	
	int b;
	int *c;
	c=&b;
	awa(&a,c)
}
```

一般传入函数中的应该是指针的地址，如上例，不能死记硬背（比如函数里面一定要有个地址符，这是错误的！！），上例的c相当于&b，所以没有使用&.

## 7.数组指针和指针数组

首先要确定的是，后面两个字，决定了它是什么类型的东西（**括号里面包着的内容决定后面两个字的性质**）。

数组指针（也称行指针）

> 定义 int (*p)[n];
> ()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。
>
> 如要将二维数组赋给一指针，应这样赋值：
>
> ```c
> int a[3][4];
> int (*p)[4]; 
> //该语句是定义一个数组指针，指向含4个元素的一维数组。
> p=a;       
> //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
> p++;       
> //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]
> ```

> 所以数组指针也称指向一维数组的指针，亦称行指针。

例:

```c
typedef char T[10] ; 
T * a ; 
```

首先是typedef，我们把这个T看成变量的声明，声明过后T的类型是什么，T就是什么。比如char T[10]；那T的类型就是char[10]; 
  然后看下面，T *a就和int *a一样，是一个指针，指向T的指针（也就是指向char[10]的指针）

指针数组

```c
定义 int *p[n];
[]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1是错误的，这样赋值也是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]...p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 *p=a; 这里*p表示指针数组第一个元素的值，a的首地址的值。
如要将二维数组赋给一指针数组:
int *p[3];
int a[3][4];
for(i=0;i<3;i++)
p[i]=a[i];
这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]
所以要分别赋值。

这样两者的区别就豁然开朗了，数组指针只是一个指针变量，似乎是C语言里专门用来指向二维数组的，它占有内存中一个指针的存储空间。指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间。
还需要说明的一点就是，同时用来指向二维数组时，其引用和用数组名引用都是一样的。
比如要表示数组中i行j列一个元素：
*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]
```



# 八、结构体和共用体

## 1.自定义数据类型typedef

```c
typedef struct Adate
{
int year;
int month;
int day;
}Date;//Date代表了 struct Adate

Date d={2023,12,7};
```

新的名字Date 是struct Adate的别名.（即结构体的第二个分号最后一个单词）

这样的好处是改善了程序的可读性，使得之后再用Adate这个结构体定义新的变量时，不需要每一次都用一个：

struct Adate=｛2023,12,7｝；

## 2.结构体的内存对齐

对齐规则：

1.第一个成员在与结构体变量偏移量为0的地址处.

2.其他成员变量要对齐到某个数字（对齐数）的整数倍的地址.

> 对齐数=编译器默认的一个对齐数与该成员大小的较小值

3.结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍.

4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处.

问：那在设计结构体的时候，我们既要满足对齐，又要节省空间，如何做到：

> 让占用空间小的成员尽量集中在一起.



**柔性数组：**

> 		把单一元素的数组放在一个struct的尾端，使得每个struct对象可以拥有可变大小的数组。
>
> 	typed在一个struct的尾端，使得每个struct对象可以拥有可变大小的数组。 



```c
typedef struct list_t{
struct list_t *next;
struct list_t *prev;
char data[0];
}list_t;
```

> 开始题目中的**char data[0]** 或写成**char  data[]**，即为柔性数组； 
>
> data不占用struct的空间，只是作为一个符号地址存在。  因此sizeof的值是两个指针所占字节，即4+4 = 8字节.

## 3.共用体的内存对齐

```c
union uti {
    int n;
    double g;
    char ch[9];
} ;
struct srt {
    float xy;
    union uti uv;
} aa;
```

> union 结构体的大小不等于所有成员的总和，因此它需要申请最大成员的整数倍空间，并且满足所有成员的需要。 
>

>   union 里面，char[]不是一个成员，是很多char成员的集合(总和超过了8，所以申请两个double），单个char的大小是1byte，所以最大的成员是double，8byte。所以申请的内存是 8*2 = 16. 
>

>   union 作为成员时，它的地址需要对齐内部最大成员的大小，是8byte，因为8byte足够前面的float使用，所以union的偏移量是8byte。 
>

>   总的内存大小：8byte+16byte = 24byte 

**修改默认对齐数**

```c
#pragma pack(8)//修改默认对齐数为8
struct
｛...｝；
#pragma pack()//取消设置的默认对齐数，还原为默认
```

**关于 offsetof**

这是一个宏变量，用于计算偏移量（struct中每一个字符在内存中的偏移量

```c
#include<stddef.h>
//这是使用offsetof必带的预处理函数
struct s
{
	int a;
};
int main
{

printf("%d\n",offsetof(struct s,a));
}
```

## 4.结构体传参

传值:

```c
void Print1(struct S tmp)
{
printf("%d%d%d",tmp.a,tmp,c,tmp.d);
}
```

传址:

```c
void Print2(struct S *ps)
{
printf("%d%d%d",ps->a,ps->c,ps->d);
}
```

> Print1(s);
>
> Print2(&s);
>
> 函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。如果传递一个结构体对象的时候，结构体过大，参数压栈的系统开销比较大，所以会导致性能的下降。
>
> 若是不想要s这个结构体在函数体内发生改变，则在struct前面加个const
>
> 即：const void Print2(struct S *ps)

## 5.位段

位域表示法
	C99规定int、unsigned int和bool可以作为位域类型，但编译器几乎都对此作了扩展，允许其它类型类型的存在。

使用位域的主要目的是压缩存储，其大致规则为：

> 1.如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；

> 2.如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；(经测试此条好像仅限于char型，整型可以跨域存储)

> 3.如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++采取压缩方式；

> 4.如果位域字段之间穿插着非位域字段，则不进行压缩；

> 5.整个结构体的总大小为最宽基本类型成员大小的整数倍。

例：

```c
struct A{
	unsigned a:19;
	unsigned b:11;
	unsigned c:4;
	unsigned d:29;
	char index;
};
```



# 九、文件操作

## 1.基本文件操作函数

打开文件**open()**：

原型：

```c
int open(const char *pathname,int access,unsigned mode);
//pathname:要打开的文件路径，可以是相对路径，也可以是绝对路径
//access:存取方式,用"宏"的“按位或”运算进行功能组合
//mode:文件类型，仅在access包含O_CREATE时有效，一般用常数0666
```


例：

int fh=open("c:\\autoexec.bat",O_ROONLY | O_TEXT);




读文件**read()**:

原型:

```c
int read(int handle,void *buf,unsigned len);
//handle:文件的句柄
//buf:内存缓存区指针
//len:试图读入的指针数
```


例：

int len=read(fh,buf,sizeof(buf)>0);




写文件**write()**:

原型：

```c
int write(int handle,void *buf,unsigned len);
//同read()
```


关闭文件**close()**:

原型：

```c
int close(int handle);
```


> open和close总是成对存在，在编写代码时，写下open()的同时马上写下close(),然后在它们之间插入代码

文件定位**lseek()**:

原型：

```c
long lseek(int handle,long offset,int fromwhere);
//offset:从fromwhere开始，移动位置指针offset字节，offset为正，表示向文件末尾移动，为负表示向文件头移动
//fromwhere:取值是下面宏中的任意一个
SEEK_SET：从文件头移动
SEEK_CUR:从当前位置指针位置移动
SEEK_END:从文件尾移动
```


例：

lseek(fh,4L,SEEK_CUR);
//从当前位置向后跳过4字节




## 2.高级文件操作

fopen()和fclose():

FILE* fp=fopen("F:\\abc.txt","a+");

| 字符串 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| “r"    | 以只读方式打开文本文件                                       |
| "w"    | 以只写方式建立并打开文本文件，已存在的文件将被覆盖           |
| "a"    | 以只写方式打开文本文件，位置指针指向文件末尾，原文件数据保留 |
| "+"    | 与上面的字符串组合，表示以读/写方式打开文件                  |
| "b"    | 与上面的字符串组合，表示以二进制方式打开文件                 |

**其他的一些ANSIC提供的函数：**

**读、写字符**

> int fgetc(FILE *p);
> int fputc(int c,FILE *fp);



**读、写字符串**

> char *fgets(char *s,int n,FILE *fp);
> int fputs(const char *s,FILE *fp);



**格式化读、写**

> int fscanf(FILE *fp,const char *format,...);
> int fprintf(FILE *fp,const char *format);



**按数据块读、写**

> unsigned fread(void *ptr,unsigned size,unsigned nmemb,FILE *fp);
> unsigned fwrite(const void *ptr,unsigned size,unsigned nmemb,FILE *fp);



**文件定位**

> int fseek(FILE *fp,long offset,int fromwhere);
> void rewind(FILE *fp);
> long ftell(FILE *fp);



**判断文件是否结束**

> int feof(FILE *fp);



**判断前一次文件操作是否有错误产生**

> int ferror(FILE *fp);
> int fflush(FILE *fp);

## 3.stdin

stdin：标准输入流(键盘处)

stdout：标准输出流(屏幕处)

# 附录

## 1.ASCII码

大、小写的ASCII码值相差32

> 即：大写字母+32=小写字母.
