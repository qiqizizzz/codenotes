# 一、c++编程基础与头文件

## 1.cout/printf和cin/scanf

```c++
#include<iostream>//"1"
cout<<"Please enter your first name:";
cin>>user_name;
```

> 要使用cout的话，头文件需包含"1"
>
> C++的iostream库和C中的stdio库中分别的cout/cin和printf/scanf相比有哪些优势呢？首先是类型处理更加安全，更加智能，我们无须应对int、float中的%d、%f，而且扩展性极强，对于新定义的类，printf想要输入输出一个自定义的类的成员是天方夜谭的，而iostream中使用的位运算符都是可重载的，并且可以将清空缓冲区的自由交给了用户（在printf中的输出是没有缓冲区的），而且流风格的写法也更加自然和简洁。
>
> cin会**忽略空格和换行符**。

## 2.C-style字符串和string对象

string对象和C-style字符串之间有两个主要差异：

- string对象会动态地随字符串长度的增加而**增加**其储存空间，C-style字符串却只能分配固定的空间，并期望这个固定空间可以容纳对应的字符串


- C-style字符串并不记录自身长度。为判断C-style字符串的长度，我们得数遍每一个元素，直至null字符出现。标准库的strlen（）就用于做这样的事情


## 3.与c不同的几个地方

1.对于声明变量，C++的做法是尽可能在首次使用变量前声明它。

2.C++有一项不寻常的特性——可以连续使用赋值运算符，赋值将从右向左进行。

3.endl在C++里面是换行的意思,\n在C++中也能使用，但最好还是用**endl**。

4.强制类型转换：

纯粹的C++格式：

```c++
int number=4;
long (number)//将其看作一个函数
```

来自C语言的格式：

```c++
(long) number
```

## 4.关于头文件#pragma once

这是一个预处理指令，用于指示编译器在一个源文件中仅包含一个特定的头文件一次。

它的主要作用是确保该头文件只会被编译一次，即使如果在多个源文件中都使用了相同或相似的头文件，也不会导致错误的发生。

> ifdef endif头文件与其有着相同的作用，但前者更为简洁。



## 5.逗号运算符

c语言提供一种特殊的运算符，**逗号运算符**，优先级别最低，它将两个袭及其以上的式子联接起来，从左往右逐个计算表达式，整个表达式的百值为最后一个表达式的值。如：（3+5,6+8）称为逗号表达式，其求解过程先表达式1，后度表达式2，整个表达式值是表达式2的值，如：（3+5，6+8）的值是14，知a=(a=35,a4)的值是60，而（a=35,a4）的值是60，a的值是15



## 6.合理的浮点数

合法的浮点数有两种表示形式：

> 十进制小数形式。他有数字和小数点组成，必须有小数点。例如（123.）（123.0）（.123）。
>
> 指数形式。如123e3。字母e（或E）之前必须有数字，e后面的指数必须为整数。 规范化的指数形式里面，小数点前面**有且只有一位**非零的数字。如1.2345e8

当指数大于等于6或小于等于−5时，将使用**科学计数法**表示。另外，字段宽度恰好容纳数字和负号（如果有的话）。



在C++标准中，**定点表示法**和**科学表示法**都有下面两个特征：

- 精度指的是小数位数，而不是总位数；
- 显示末尾的0。



## 7.sizeof与strlen的区别

sizeof和strlen不同，主要有两点：

```c++
1.sizeof对于一个字符进行求长度需要注意末尾'/0'，而strlen遇到'/0'自动结束；
2.当数组作为参数,strlen是函数，参数只能是*p形式，因此数组名会退化为指针，即为定义类型名大小，而sizeof可以传数组，计算出来的为数组的类型*个数
```



## 8.短路求值法

```c++
if(user_rsp=='N' || user_rsp=='n')
	user_more=false;
```

只需左右两个表达式的其中一个为true，OR(||)逻辑运算符的求职结果便为true。左侧表达式会先被求值，如果值为true，剩下的另一个表达式就**不需要再被求值**（直接被跳过了）。

> &&运算符也与此类似
>
> 如果值为false，剩下的另一个表达式就**不需要再被求值**（直接被跳过了）。



## 9.运算符优先级

> 由上到下优先级递减，同一行优先级相同（运算顺序由左至右）

逻辑运算符 NOT

算术运算符（*，/ ，%）

算术运算符（+，-）

关系运算符（<，>，<=，>=）

关系运算符（==，！=）

逻辑运算符 AND

逻辑运算符 OR

赋值运算符



# 二、处理数据

## 1.C++命名规则

- 在名称中只能使用字母字符、数字和下划线(_)

- 名称的第一字符不能是数字

- 区分大写字符和小写字符

- 不能将C++关键字用作名称

- 以两个下划线打头或以下划线和大写字母打头的名称被保留给实现(编译器及其使用的资源)使用。以一个下划线开头的名称被保留给实现，用作全局标识符。

- C++对于名称的长度没有限制，名称中的所有字符都有意义，但有些平台有长度限制。

## 2.关于头文件climits

头文件climits定义了符号常量来表示类型的限制。

| 符号常量   | 表示                       |
| ---------- | -------------------------- |
| CHAR_BIT   | char的位数                 |
| CHAR_MAX   | char的最大值               |
| CHAR_MIN   | char的最小值               |
| SCHAR_MIN  | signed char的最小值        |
| SCHAR_MAX  | signed char的最大值        |
| UCHAR_MAX  | unsigned char的最大值      |
| SHRT_MAX   | short的最大值              |
| SHRT_MIN   | short的最小值              |
| USHRT_MAX  | unsigned short的最大值     |
| INT_MAX    | int的最大值                |
| INT_MIN    | int的最小值                |
| UNIT_MAX   | unsigned int的最大值       |
| LONG_MAX   | long的最大值               |
| LONG_MIN   | long的最小值               |
| ULONG_MAX  | unsigned long的最大值      |
| LLONG_MAX  | long long的最大值          |
| LLONG_MIN  | long long的最小值          |
| ULLONG_MAX | unsigned long long的最大值 |

## 3.C++特有的一种初始化

```c++
int wrens(432);
//把432赋给wrens这个变量
int emus{7};
//把7赋给数组(或者结构)emus
```

## 4.各进制的控制符dec、hex和oct

dec、hex和oct分别用于指示cout以十进制、十六进制和八进制格式显示整数，默认格式为十进制。

```c++
#include<bitset>

cout <<dec<<35<<endl;     //以十进制形式输出
cout <<hex<<35<<endl;     //以十六进制形式输出
cout <<oct<<35<<endl;     //以八进制形式输出
cout <<bitset<8>(35)<<endl;    //以二进制形式输出
8是预留的位置
```

![QQ图片20240418192245](E:\代码笔记\笔记图片保存\QQ图片20240418192245.jpg)



## 5.wchar_t、char16_t和char32_t

wchar_t

- 一种整数类型，有足够的空间，可以表示系统使用的最大扩展字符集。


- wcin和wcout可用于处理wchar_t流


- 用前缀**L**表示其字符串字面值

char16_t、char32_t

> C++11使用前缀u表示char16_t字符常量和字符串常量，并使用前缀U表示char32_t常量

## 6.原始字符串

用前缀**R**表示，将"(和)"用作定界符

```c++
cout <<R"(Jim "king" Tutt uses "\n" instead of endl.)" << '\n';
上述代码将显示如下内容
Jim "King" Tutt uses "\n" instead of endl.
```

> 若字符串中包含定界符“(和)",则使用"+*(和

> )+*"替代默认定界符

> 可将前缀R与其他字符串前缀结合使用，以标识wchar_t等类型的原始字符串。

# 三、复合类型

## 1.getline()、get()和ignore()

> 非格式化输入函数（不会跳过空白，也不进行数据转换，只是读取字符输入）

### 1.1 getline()语法：(**仅用于char数组！！！**)

```c++
//原型

istream & getline(char*,int,char);        //1  第三个参数用于指定分界符
istream & getline(char*,int);             //2

//用法
getline(input_stream,string_variable);
//getline函数读取整行，通过以回车键输入的换行符来确定输入结尾.
//第一个参数用来存储书入行的数组名称
//第二个参数是要读取的字符数
cin.getline(name,20);   //适用于char数组 
或者getline(cin,str);   //适用于C++string类
cin.getline(input,limit,'#');    //遇到分界字符'#'后，输入将停止

```

### 1.2 get()语法:

另一种与其相似的**get()函数**则不再读取并丢弃换行符，以下是处理换行符的方法：

```c++
//原型
//1
istream & get(char *,int,char);
//2
istream & get(char *,int);
```

以下方法**仅用于char数组！**

连续读取两行字符：

1.

```c++
cin.get(name,ArSize);
cin.get();
cin.get(dessert,Arsize);
```

2.

```c++
cin.get(name,ArSize).get();
```

3.

```c++
cin.getline(name1,ArSize).getline(nname2,ArSize);
```

注：

cin.get()的作用是“吃掉”用户输入的换行符，防止换行符被第二个cin读入.



### 1.3 igone()语法：

```c++
//原型：
istream & ignore(int=1,int=EOF);
//用法：
cin.ignore(255,'\n');
```

默认参数值EOF导致ignore( )读取指定数目的字符或读取到文件尾。



## 2.string类

string类具有**自动调整大小**的功能，能够避免因字符串太长导致数据被损坏。

语法：

- 可以用”=“将一个string对象赋给另一个string对象


- 可以用”+“将两个string对象合并起来


- 可以用”+=“将字符串附加到string对象的末尾
- 可以用cout直接输出某个string字符串

C++中 **确定字符串长度**的方法：

```c++
string str1="patnter";
int lenth=str1.size();    //size()是一个类方法
```

## 3.动态分配的(new-delete运算符)

对于一般变量：

```c++
int* pt1=new int;
delete pt1;
double* pt2=new double;
delete pt2;
```

对于数组：

```c++
int * psome=new int [10];
delete [] psome;
```

对于结构体:

```c++
struct kk...  //创建一个结构体
kk *ps；
ps=new kk[Size];
```

总结：

> 1.不要使用delete来释放不是new分配的内存

> 2.不要使用delete释放同一个内存块两次

> 3.如果使用new[]为数组分配内存，则应使用delete来释放

> 4.如果使用new为一个实体分配内存，则应使用delete (没有方括号)来释放

> 5.对空指针应用delete是安全的

## 4.模板类vector和模板类array(C++11)

vector:(长度可以自动调整，效率比数组低)

一种动态数组，使用时需包含**头文件vector**，且可使用using编译指令、using声明或std::vector.

```c++
#include<vector>
...
using namespace std;  //using编译指令
vector<int>vi;        //创造一个int类型的数组
					  //vector对象可以在您插入或添加值时自动调整长度，因此可以将vi的初始长度设置成0
int n;
cin >> n
vector<double>vd(n);   //创造一个长度为n的double类型的数组

vector<typeName>vt(n_elem)
					   //n_elem可以是整型变量，也可以是整型常量
```



array:(长度固定，比数组方便和安全)

```c++
#include<array>
...
using namespace std;
array<int,5>ai;
array<double,4>ad={1.2,2.1,3.43,4.3};

array<typeName,n_elem>arr;
						    //n_alem不能是变量
```



二者的成员函数at():

- 使用at()时，将在运行期间捕获非法索引，而程序默认将中断。


a2.at(1)=2.3  即   at[1]=2.3

# 四、循环和关系表达式

## 1.控制语句的书写规则

> 为将for语句和函数调用区分，一般在for和括号之间加上一个空格，而省略函数名和括号之间的空格(其他控制语句，如if，while也与其相似) 



一条有效但无用的C++语句

```c++
rodents+6;    //程序仅仅是计算和，而没有使用得到的结果
```

## 2.<<运算符的优先级

由于<<运算符的优先级比表达式中使用的运算符高，因此代码使用括号来获得正确的运算顺序

```c++
int x=100;
cout << (x<3) <<endl;   //x<3为假，则输出0
```

关系运算符的优先级比算术运算符**低**

## 3.递增递减运算符

对于类而言，前缀格式的效率更高

## 4.C++中的while循环(三个输入方法)

> 1.使用原始的cin进行输入

选择某个特殊字符(也被称为**哨兵字符**)，将其作为停止标记，但遇到空格和换行符不会回显。

> 2.使用cin.get(char)进行补救

这时遇到空格和换行符就会回显了。

> 3.使用哪一个cin.get()

```c++
cin.get(ch);
cin.get(name,ArSize);
cin.get();
//函数重载
```

> 4.文件尾条件

cin.get(char)成员函数调用通过返回转换为false的bool值来指出已到达EOF，而cin.get()成员函数调用则是通过返回EOF值来指出已到达EOF，EOF是在iostream中定义的。

## 5.基于范围的for循环(C++11)

```c++
double prices[5]={4.99,10.99,6.87,7.99,8.49};
for(double x:prices)
cout <<x <<std:endl;
```

上述代码会不断执行循环，最终显示全部5个元素。

若要修改数组中的元素，则应将第二行代码改为

for(double **&**x:prices);   //&表明x是一个引用变量



# 五、分支语句和逻辑运算符

## 1.逻辑运算符的另一种表示方式

| 运算符 | 另一种表示方式 |
| ------ | -------------- |
| &&     | and            |
| \|\|   | or             |
| ！     | not            |

## 2.字符函数库cctype

- 可以简化诸如确定字符是否为大写字母、数字、标点符号等工作。


| 函数名称   | 返回值                                                       |
| ---------- | ------------------------------------------------------------ |
| isalnum()  | 如果参数是字母数字，即字母或数字，该函数返回true             |
| isalpha()  | 如果参数是字母，则该函数返回true                             |
| iscntrl()  | 如果参数是控制字符，该函数返回true                           |
| isdigit()  | 如果参数是数字(0~9)，该函数返回true                          |
| isgragh()  | 如果参数是除空格之外的打印字符，该函数返回true               |
| islower()  | 如果参数是小写字母，该函数返回true                           |
| isprint()  | 如果参数是打印字符(包括空格)，该函数返回true                 |
| ispunct()  | 如果参数是标点符号，该函数返回true                           |
| isspace()  | 如果参数是标准空白字符，如空格、进纸、换行符、回车、水平制表符或者垂直制表符，该函数返回true |
| isupper()  | 如果参数是大写字符，则函数返回true                           |
| isxdigit() | 如果参数是十六进制数字，即0~9、a~f或A~F，该函数返回true      |
| tolower()  | 如果参数是大写字符，则返回其小写，否则返回该参数             |
| toupper()  | 如果参数是小写字符，则返回其大写，否则返回该参数             |

```c++
//用法
string a="abc";
for(int i=0;i<sizeof(a);i++)
{
	a[i]=toupper(a[i]);        //将小写字符转换为大写
}
for(int i=0;i<sizeof(a);i++)
{
	cout <<a[i];               //打印
}
```



## 3.is_open()函数与文件基础

检查文件是否被成功打开的首先方法是使用方法is_open()，如果文件被成功地打开，方法is_open()将返回true。

exit()的原型是在头文件cstdlib中定义的。

1）fstream是头文件；

2）**ifstream**和**ofstream**分别是用来打开和输出文件；

3）.open()函数是用来打开文件，比如：ifs.open("m.txt", ios::in)；就会打开名为“m.txt”的文件了；

4）is_open()函数是用来判断文件是否打开成功，返回值是布尔值；例如：ifs.is_open( )；

5）good()函数是指文件读取成功；

6）.eof()函数是用来判断是否读到了文件尾；

7）.close()函数是用来关闭之前打开的文件；

8）.fail()函数用来判断一个流是否“坏”掉了，当输入流读取失败时，会将字符放在原处，等待下一次读取；



打开文件的基础代码:

```c++
#include<fstream>      //头文件
...
ifstream fin;
string file_name;
cout <<"Enter the file name:";
getline(cin,file_name);
fin.open(file_name);   //通过文件流对象打开文件

/*如果在打开文件时出现错误，则终止程序*/
if(!fin.is_open())
{
	cout <<"Error to open file."<<endl;
	exit(EXIT_FAILURE);
}

/*通过eof()函数判断是否到达文件末尾*/
char read_char;
int char_counter=0;
while(!fin.eof())
{
	fin>>read_char;
	char_counter++;   //实现例题要求:统计文件中的字符个数
}

...
fin.close();  //关闭文件
```



# 六、函数

## 1.数组函数

> 1.为将**数组类型**和**元素数量**告诉数组处理函数，请通过两个不同的参数来传递它们：

```c++
void fillArray(int arr[],int size);   //正确的
```

而不要试图使用方括号表示法来传递数组长度：

```c++
void fillArray(int arr[size]);        //错误的
```



> 2.为避免函数无意修改数组中的内容，可在声明形参时使用关键字**const**:

```c++
void show_array(const double ar[],int n);
//即此函数将数组视为只读数据

因此若此函数里面做了任何修改数组的操作。编译器会给出一条错误信息以示警告
```

注:

我们可以将常规变量的地址赋给常规指针，将常规变量的地址赋给指向const的指针，将const变量的地址赋给指向const的指针(此类情况仅当只有一层间接关系"如指针指向基本数据类型"时才可以将非const指针或地址赋给const指针)。

**但不能**将const的地址赋给常规指针。C++禁止将const的地址赋给非const指针。





> 3.使用**两个指针**来指定区间:

一个指针标识数组的开头，另一个指针标识数组的尾部。

```c++
int sum_arr(const int * begin,const int * end);
...
//cookies是一个数组名
int sum=sum_arr(cookies,cookies+3);   //数组最开始的三个元素
...
//构建函数
int sum_arr(const int * begin,const int * end)
{
	const int *pt;
	int total=0;

	for(pt=begin;pt!=end;pt++)
		total+=*pt;
	return total;
	}//注意必须按顺序传递指针，因为此代码假定begin在前
```



> 4.指针数组(这好像不是指针数组，不知道叫什么)

```
char *Snames[]={"Spring","Summer","Fall","Winter"};
//若把*去掉，则会出现一条错误信息：该语句的争议性很高、
char Sname[]=“SpringSummer”;
```

如果加上*的话每个元素都是一个指针，如果去掉的话就是每个元素都是一个字符串(即只能存储**一个**连续的字符串，而不能通过数组将每个字符串分开)，和前面的char修饰符冲突

## 2.const在指针中的好处

尽可能使用const。

- 使用const使得函数能够处理const和非const实参，否则将只能接受非const数据。

- 如果条件允许，则应将指针形参声明为指向const的指针。

  

```c++
int sloth=3;
const int *ps=&sloth;
int *const finger=&sloth;

const在*的左边，则指针指向的变量的值不可直接通过指针改变(可以通过其他途径改变);在*的右边，则指针的指向不可变。简记为"左定值，右定向"。

//第二种使用const的方式使得无法修改指针的值：
在最后一个声明中，关键字const的位置与以前不同。这种声明格式使得finger只能指向sloth，但允许使用finger来修改sloth的值。中间的声明不允许使用ps来修改sloth的值，但允许将ps指向另一个位置。简而言之，finger和*ps都是const，而*finger和ps不是
```



## 3.C风格字符串与函数

- 在函数中，将字符串作为参数来传递，实际上传递的是字符串第一个字符的地址，因此将char*作为字符串处理函数的参数。

> C-风格字符串与常规char数组之间的一个重要区别是，字符串有内置的结束字符（前面讲过，包含字符，但不以空值字符结尾的char数组只是数组，而不是字符串）。这意味着不必将字符串长度作为参数传递给函数，而函数可以使用循环依次检查字符串中的每个字符，直到遇到结尾的空值字符为止。



处理字符串中字符的标准方式：

```c++
while(*str)
{
	statements    //其他语句
	str++;
}

//str最初指向字符串的第一个字符，因此*str表示的是第一个字符。
例如，第一次调用该函数后，*str的值将为m——“minimum”的第一个字符。只要字符不为空值字符（\0），*str就为非零值，因此循环将继续。在每轮循环的结尾处，表达式str++将指针增加一个字节，使之指向字符串中的下一个字符。最终，str将指向结尾的空值字符，使得*str等于0——空值字符的数字编码，从而结束循环。

```



## 4.结构体与函数

- 与数组名就是数组第一个元素的地址不同的是，结构名只是结构的名称，要获得结构的地址，必须使用地址运算符&。

传递结构的方式：

> 1.传递和返回结构：(按值传递用来处理较小的结构)

```c++
const int Mins_per_hr=60;
struct travel_time
{
		int hours;
		int mins
};
...
travel_time day1={5,45};      //5:45
travel_time day2={4,55};      //4:55
...(在一个函数中)
{travel_time total;
total.mins=(t1.mins+t2.mins)%Mins_per_hr;
total.hours=t1.hours+t2.hours+(t1.mins+t2.mins)/Mins_per_hr;
return total;
}
```



> 2.传递结构的地址

- 调用函数时，将结构的地址（&pplace）而不是结构本身（pplace）传递给它；

```c++
//box是一个结构体
void Print(box);
Print(box);
void awa(box*);      //传递结构的地址的函数头
awa(&box)
```

- 将形参声明为指向polar的指针，即polar *类型。由于函数不应该修改结构，因此使用了const修饰符；
- 由于形参是指针而不是结构，因此应间接成员运算符（->），而不是成员运算符（句点）。



> 3.引用传递

//见第七章第四节

## 5.cin.clear()函数

- 如果程序在输入循环后还需要进行输入，则必须使用cin.clear( )重置输入，然后还可能需要通过读取不合法的输入来丢弃它们。



## 6.指针与函数

- 正确的指针声明:

```c++
double (*pf)(int);`

//为提供正确的运算符优先级，必须在声明中使用括号将*pf括起。
括号的优先级比*运算符高，因此*pf（int）意味着pf( )是一个返回指针
的函数，而（*pf）（int）意味着pf是一个指向函数的指针
```

- 使用指针来调用函数:

```c++
double pam(int);
double (*pf)(int);
pf=pam;
double x=pam(4);
double y=(*pf)(5);    //1
double y=pf(5)        //2
```

> 1和2等价，但1更能说明代码在使用函数指针

- 创建指向整个数组的指针:(使用**auto**)

  ```c++
  auto pc=&pa;
  //也可以自己声明，但比较麻烦
  const double *(*(*pd)[3])(const double*,int)=&pa; 
  ```

  

# 七、函数探幽

## 1.内联函数

> 内联函数是C++为提高程序运行速度所做的一项改进。内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。如果代码执行时间很短，则内联调用就可以节省非内联调用使用的大部分时间。

要使用这项特性，必须采取下述措施之一：

- 在函数声明前加上关键字inline；
- 在函数定义前加上关键字inline。

```c++
inline double square(double x){return x*x};
//我们注意到整个函数定义都放在一行中，但并不一定非得这样做。然而，如果函数定义占用多行（假定没有使用冗长的标识符），则将其作为内联函数就不太合适。
```

宏不能按值传递，如果使用C语言的宏执行了类似函数的功能，应考虑将它们转换为C++内联函数。

注：inline仅仅是让函数尽可能快的执行函数，但具体是用内联方式还是普通方式执行函数，还要看编译阶段。同样，如果函数足够短小，逻辑足够简单，编译器仍然会以内联方式编译这个函数。



## 2.引用变量

> C++新增了一种复合类型——引用变量。引用是已定义的变量的别名（另一个名称）。

```c++
int rats;
int & rodents=rats;     //左值引用
//这里的&是类型标识符的一部分，用来声明引用，而不是地址运算符

double && rref=sqrt(36.00)    //右值引用
//C++11新增了另一种引用——右值引用（rvalue reference）。这种引用可指向右值，是使用&&声明的：
```

与指针(传递指针)的不同之处:

- 差别之一是，必须在**声明引用时将其初始化**，而不能像指针那样，先声明，再赋值。
- 另一个区别是指针版本需要在函数使用p和q的整个过程中使用解除引用运算符*。



> 1.引用传递

- 引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。这种传递参数的方法称为按引用传递。
- 按引用传递允许被调用的函数能够访问调用函数中的变量。（C++新增的这项特性是对C语言的超越，C语言只能按值传递）

> 2.引用的属性和特别之处

- 如果程序员的意图是让函数使用传递给它的信息，而不对这些信息进行修改，同时又想使用引用，则应使用**常量引用**。

```c++
double refcube(const double &ra);         //const就是一个例子
//在使用这个函数的时候，不能将变量之外的数(如表达式等）传入
double z=refcube(x+3.0);                  //错误的用法，x+3.0不是一个变量
```

- 当数据比较大（如结构和类）时，引用参数将很有用

## 3.临时变量、引用参数和const

如果实参与引用参数不匹配，C++将生成临时变量。当前，仅当参数为**const引用**时，C++才允许这样做，但以前不是这样。

下面来看看何种情况下，C++将生成临时变量，以及为何对const引用的限制是合理的。

```c++
double side=3.0;
double *pd=&side;
double & rd=side;
long edge=5L;
double lens[4]={2.0,5.0,10.0,12.0};

double c1=refcube(side);
double c2=refcube(lens[2]);
double c3=refcube(rd);
double c4=refcube(*pd);

double c5=refcube(edge);         //临时变量
double c6=refcube(7.0);          //临时变量
double c7=refcube(side+10.0);    //临时变量
```

在c5,c6,c7这些情况下，编译器都将生成一个**临时匿名变量**，并让ra指向它。这些临时变量只在函数调用期间存在，此后编译器便可以**随意**将其删除。

A1：如果**引用参数是const**，则编译器将在下面两种情况下生成临时变量：

- 实参的类型正确，但不是左值；

- 实参的类型不正确，但可以转换为正确的类型。

  > 左值是什么呢？左值参数是可被引用的数据对象，例如，变量、数组元素、结构成员、引用和解除引用的指针都是左值。非左值包括字面常量（用引号括起的字符串除外，它们由其地址表示）和包含多项的表达式。

A2：如果实参不匹配，则其行为类似于按值传递，为**确保原始数据不被修改**，将使用临时变量来存储值。

A3：应尽可能使用const

将引用参数声明为常量数据的引用的理由有三个：

- 使用const可以避免无意中修改数据的编程错误；

- 使用const使函数能够处理const和非const实参，否则将只能接受非const数据；

- 使用const引用使函数能够正确生成并使用临时变量。

  因此，应尽可能将引用形参声明为const。

A4：使用**引用参数**的原因：

- 程序员能够修改调用函数中的数据对象。

- 通过传递引用而不是整个数据对象，可以提高程序的运行速度。

  当数据对象较大时（如结构和类对象），第二个原因最重要。这些也是使用指针参数的原因。这是有道理的，因为引用参数实际上是基于指针的代码的另一个接口。

A5:将引用用于结构:

返回引用的效率要高于传统返回机制。

> 注：
>
> 1. 应避免返回一个指向临时变量的引用
> 2. 同时避免返回指向临时变量的指针

为避免上述问题，最简单的方法是返回一个作为参数传递给函数的引用，另一种方法是用new来分配新的存储空间。

```c++
const free_throws & clone(free_throws & ft)
{
	free_throws *pt;
	*pt=ft;
	return *pt;
}
free_throws & jolly=clone(three);
//调用clone隐藏了对new的引用，以致于忘记使用delete来释放内存
```

A6:何时使用引用、指针、按值传递:

> 对于使用传递的值而不作修改的函数:

- 如果数据对象很小，如内置数据类型或小型结构，则按值传递。
- 如果数据对象是**数组**，则使用**指针**，因为这是唯一的选择，并将指针声明为指向const的指针。
- 如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。
- 如果数据对象是**类对象**，则使用**const引用**。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。

> 对于修改调用函数中数据的函数：

- 如果数据对象是内置数据类型，则使用指针。如果看到诸如fixit（&x）这样的代码（其中x是int），则很明显，该函数将修改x。
- 如果数据对象是数组，则只能使用指针。
- 如果数据对象是结构，则使用引用或指针。
- 如果数据对象是类对象，则使用引用。



## 4.对象、继承和引用

使得能够将特性从一个类传递给另一个类的语言特性被称为**继承**

> 简单地说，ostream是基类（因为ofstream是建立在它的基础之上的），而ofstream是派生类（因为它是从ostream派生而来的）。派生类继承了基类的方法，这意味着ofstream对象可以使用基类的特性，如格式化方法precision( )和setf()。
> 继承的另一个特征是，基类引用可以指向派生类对象，而**无需进行强制类型转换**。这种特征的一个实际结果是，可以定义一个接受基类引用作为参数的函数，调用该函数时，可以将基类对象作为参数，也可以将派生类对象作为参数。



## 5.ostream类中的一些格式化方法

### 5.1 方法width( )

> 1.调整字段宽度(作用)

可以使用width成员函数将**长度不同**的数字放到**宽度相同**的字段中，设置下一次输出操作使用的字段宽度，这种设置只在显示下一个值时有效，然后将恢复到默认设置。默认的字段宽度为零，这意味着刚好能容纳下要显示的内容。

注：默认的字段宽度为**0**。

> 2.原型

```c++
int width();
int width(int i);
```

- 第一种格式返回字段宽度的当前设置；

- 第二种格式将字段宽度设置为i个空格，并返回以前的字段宽度值。这使得能够保存以前的值，以便以后恢复宽度值时使用。

  注：width( )方法**只影响**将显示的**下一个**项目

> 3.用法

```c++
cout.width(12);
cout <<12<<"#"<<24<<"#\n";
//输出结果为:
          12#24#     //12左边有10个空格，这是右对齐
```



### 5.2 成员函数fill()

> 1.填充字符(作用)

在**默认**情况下，cout用**空格**填充字段中未被使用的部分，可以用fill( )成员函数来改变填充字符。

> 2.用法

```c++
cout.fill('*');
```

注：与字段宽度不同的是，新的填充字符将**一直有效**，直到更改它为止。



### 5.3 方法precision( )

> 1.设置浮点数的显示精度（作用）

指定显示多少位小数（假定对象处于定点模式下）。所有这些设置都将一直保持不变，直到再次调用相应的方法重设置它们。

注：C++的**默认精度**为**6**位(但末尾的0将不显示)

> 2.用法

```c++
cout.precision(2);
//如果输出结果的非小数部分的长度小于2，则输出非小数部分
//2应该是包括非小数部分和小数部分的总长度

//不知道为什么洛谷用上面的方法代码不让过
cout<<setprecison(2)<<fixed;  //这样就行了
```

注：新的精度设置将**一直有效**，直到被重新设置。



### 5.4 函数setf()

> 1.打印末尾的0和小数点(作用)

方法setf( )让您能够设置各种格式化状态。

> 2.原型

1.

```c++
fmtflags setf(fmtflags);
```

格式常量：

| 常 量                | 含 义                                   |
| -------------------- | --------------------------------------- |
| ios_base ::boolalpha | 输入和输出bool值，可以为true或false     |
| ios_base ::showbase  | 对于输出，使用C++基数前缀（0，0x）      |
| os_base ::showpoint  | 显示末尾的小数点                        |
| ios_base ::uppercase | 对于16进制输出，使用大写字母，E表示法   |
| ios_base ::showpos   | 在正数前面加上+(当基数为10时才使用加号) |

2.

```c++
fmtflags setf(fmtflags,fmtflags);
```



参数表：（无序列表的是第二个参数）

1.**ios_base ::basefield**（第一个参数）

- ios_base ::dec：使用基数10

- ios_base ::oct：使用基数8

- ios_base ::hex：使用基数16

2.**ios_base ::floatfield**（第一个参数）

- ios_base ::fixed：使用定点计数法

- ios_base ::scientific：使用科学计数法

3.**ios_base ::adjustfield**（第一个参数）

- ios_base ::left：使用左对齐

- ios_base ::right：使用右对齐

- ios_base ::internal：符号或基数前缀左对齐，值右对齐



> 3.用法

```
//1
cout.setf(ios_base::uppercase);
//2
cout.setf(ios_base::left,ios_base::adjustfield);
```



> 4.默认模式的启动方法

```
//1
cout.setf(0,ios_base::floatfield);
//2
cout.unsetf(ios_base::floatfield);
```



### 5.5 头文件iomanip

一些其他的控制符：

3个最常用的控制符分别是setprecision( )、setfill( )和setw( )，它们分别用来设置精度、填充字符和字段宽度。与前面讨论的控制符不同的是，这3个控制符带参数。

- setprecision( )控制符接受一个指定精度的整数参数；

- setfill( ) 控制符接受一个指定填充字符的char参数；

- setw( )控制符接受一个指定字段宽度的整数参数。由于它们都是控制符，因此可以用cout语句连接起来。

```
cout <<setw(6)<<setfill('.')<<n<<setprecision(3)<<root<<endl;
```



## 6.默认参数

> 默认参数指的是当函数调用中省略了实参时自动使用的一个值。

```c++
char *left(const char *str,int n=1);   //将n的默认值设置为0
int chico(int n,int m=6,int j);        //错误的
beeps=harpo(3, ,8);                    //错误的
//默认参数需在头文件中进行初始化
```

- 对于带参数列表的函数，必须**从右向左**添加默认值。也就是说，要为某个参数设置默认值，则必须为它右边的所有参数提供默认值。

- 实参按**从左到右**的顺序依次被赋给相应的形参，而不能跳过任何参数。



## 7.函数重载

> 函数重载指的是可以有多个**同名**的函数，因此对名称进行了重载。

仅当函数基本上执行**相同**的任务，但使用不同形式的数据时，才应采用函数重载

```c++
long gronk(int n,float m);
double gronk(int n,float m);
//错误的重载方式
返回类型不同，特征标相同的两个函数并不能被认为是函数重载
```

返回类型**不同**，特征标**不同**的两个函数可以被认为是函数重载



重载规则：

- 函数名相同
- 参数必须不同（个数或类型或顺序）
- 返回值类型可以相同也可以不同



## 8.函数模版

```c++
template<typename AnyType>
AnyType Swap(AnyType &a,AnyType &b)
{
	AnyType temp;
	temp=a;
	a=b;
	b=temp;
}
//关键字template和typename(或class)是必须的
```

- 如果需要多个将同一种算法用于不同类型的函数，请使用模板。如果不考虑向后兼容的问题，并愿意键入**较长**的单词，则声明类型参数时，应使用关键字typename而不使用class。

- 使用模板的好处是，它使生成多个函数定义更简单、更可靠。
- **并非**所有的模板参数都必须是模板参数类型。

> 显式具体化：

```c++
template <> void Swap<job>(job &,job &);
或template <> void Swap(job &,job &);    //job应该是具体的某个类型，如int，char等
//创建类模版时<>里需要写明具体的某个类型
//如:template<int> A;   //创建一个名为A的int类型的类模版
```

方法：

- 对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本。
- 显式具体化的原型和定义应以template<>打头，并通过名称来指出类型。
- **具体化优先于常规模板，而非模板函数优先于具体化和常规模板**。

> 显式实例化：

```c++
template void Swap<int>(int ,int);
```

隐式实例化、显式实例化和显式具体化统称为具体化

> 关键字decltype

```c++
decltype (expression) var;
//expression可以为标识符（没有被括号括起来），则var与标识符类型相同
可以为函数引用、左值
作用是帮助重载解析更好地选择重载函数
```

​          

# 八、内存模型和名称空间

## 1.单独编译

> 1.头文件常包含的内容：（不要将**函数定义或变量声明**放到头文件中。这样做对于简单的情况可能是可行的，但通常会引来麻烦。）

- 函数原型。
- 使用#define或const定义的符号常量。
- 结构声明。
- 类声明。
- 模板声明。
- 内联函数。

包含自己的头文件的声明：

```c++
#include "coordin.h"   //用引号(“”)而不是尖括号（<>）
//警告：在IDE（集成开发环境）中，不要将头文件加入到项目列表中，也不要在源代码文件中使用#include来包含其他源代码文件。
```

> 2. 头文件管理：

```c++
//下面的代码片段1意味着仅当以前没有使用预处理器编译指令#define定义名称COORDINH时，才处理#ifndef和#endif之间的语句：

//1
#ifndef COORDIN_H_          
...
#endif

//防护方案：防止在一个文件中定义同一个结构两次

//2
#ifndef COORDIN_H_ 
#define COORDIN_H_             //对该名称的定义
...
#endif

```

  

## 2.静态持续变量及变量存储方式

所有静态持续变量在整个程序执行期间都存在。

```c++
int global=1000;            //1   由于global的链接性为外部，因此可以在程序的其他文件中使用它。
static int one_file=50;     //2   由于one_file的链接性为内部，因此只能在包含上述代码的文件中使用它；

int main()
{
	...
}
void funct1(int n)
{
	static int count=0;     //3   
	...
}
```

> 1.要想创建链接性为**外部**的静态持续变量，必须在代码块的外面声明它；
>
> 2.要创建链接性为**内部**的静态持续变量，必须在代码块的外面声明它，并使用static限定符；
>
> 3.要创建**没有链接性**的静态持续变量，必须在代码块内声明它，并使用static限定符。



5种变量储存方式

| 存储描述         | 持续性 | 作用域 | 链接性 | 如何声明                         |
| ---------------- | ------ | ------ | ------ | -------------------------------- |
| 自动             | 自动   | 代码块 | 无     | 在代码块中                       |
| 寄存器           | 自动   | 代码块 | 无     | 在代码块中，使用关键字register   |
| 静态，无链接性   | 静态   | 代码块 | 无     | 在代码块中，使用关键字static     |
| 静态，外部链接性 | 静态   | 文件   | 外部   | 不在任何函数内                   |
| 静态，内部链接性 | 静态   | 文件   | 内部   | 不在任何函数内，使用关键字static |



## 3.定义声明和引用声明

> 1.定义声明

一种是定义声明或简称为定义，它给变量**分配**存储空间；

> 2.引用声明

另一种是引用声明或简称为声明，它不给变量分配存储空间，因为它**引用**已有
的变量。

- 引用声明使用关键字**extern**，且不进行初始化；
- 定义与全局变量同名的局部变量后，局部变量将隐藏全局变量。



## 4.说明符和限定符

> **1.存储说明符：**

- auto（在C++11中不再是说明符）：在C++11之前，可以在声明中使用关键字auto指出变量为自动变量；但在C++11中，auto用于自动类型推断。关键字register用于在声明中指示寄存器存储，而在C++11中，它只是显式地指出变量是自动的。
- register；

- static：关键字static被用在作用域为整个文件的声明中时，表示内部链接性；被用于局部声明中，表示局部变量的存储持续性为静态的。

- **extern**：关键字extern表明是引用声明，即声明引用在其他地方(即其他文件)定义的变量。

- thread_local（C++11新增的）：关键字thread_local指出变量的持续性与其所属线程的持续性相同。thread_local变量之于线程，犹如常规静态变量之于整个程序。
- mutable：关键字mutable的含义将根据const来解释。可以用它来指出，即使结构（或类）变量为
  const，其某个成员也**可以被修改**



> **2.cv-限定符**

- const:一般放在函数头后面，表示这个函数是常成员函数，不能改变成员变量值，即只读函数
  - const对象只能调用const成员函数。
  - const对象的值不能被修改，在const成员函数中修改const对象数据成员的值是语法错误 。
  -  在const函数中调用非const成员函数是语法错误

- volatile：该关键字的作用是为了**改善编译器的优化能力**。

例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会变化。如果不将变量声明为volatile，则编译器将进行这种优化；将变量声明为volatile，相当于告诉编译器，不要进行这种**优化**（由于编译器发现两次从i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在b 中。而不是重新从i里面读。这样以来，如果i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile可以保证对特殊地址的稳定访问）。



## 5.std:size_t与new原函数的关系

```c++
void *operator new(std::size_t);
```

std::size_t是一个typedef，对应于合适的整型。



## 6.定位new运算符和常规new运算符

```c++
#include<new>
int *p1=new int;    //常规
int *p2=new (buffer) int;     //定位
```



## 7.using声明和using编译指令及名称空间

1.**名称空间**：(namespace)

```c++
namespace Jill
{
	double fetch;
	int pal;
	void void setSales(Sales& s, const double ar[], int n);
	void setSales(Sales& s)；
	...
}

namespace j=Jill;     //将j作为Jill的别名

//名称空间的扩展(除了补充没完成的函数之外还能加入新的内容)
namespace Jill
{
	void setSales(Sales& s, const double ar[], int n)
	{
		//写出完整的函数代码
	}
	void setSales(Sales& s)
	{
		...
	}
}
```

- 名称空间是开放的，即可以把名称加入到已有的名称空间中。

2.**using声明**由被限定的名称和它前面的关键字using组成:

```c++
using Jill::fetch;
```

一般说来，使用**using声明**比使用using编译指令更安全，**这是由于它只导入指定的名称**。如果该名称与局部名称发生冲突，编译器将发出
指示。using编译指令导入所有名称，包括可能并不需要的名称。

3.**using编译指令**由名称空间名和它前面的关键字using namespace组成，它使名称空间中的所有名称都可用，而不需要使用作用域解析运算符（：:）

```c++
using namespace std;
```

4.名称空间及其前途

- 使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。
- 使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。
- 如果开发了一个函数库或类库，将其放在一个名称空间中。事实上，C++当前提倡将标准函数库放在名称空间std中，这种做法扩展到了来自C语言中的函数。例如，头文件math.h是与C语言兼容的，
- 没有使用名称空间，但C++头文件cmath应将各种数学库函数放在名称空间std中。实际上，并非所有的编译器都完成了这种过渡。

- 仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计。
- 不要在头文件中使用using编译指令。首先，这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非要使用编译指令using，应将其放在所有预处理器编译指令#include之后。
- 导入名称时，首选使用作用域解析运算符或using声明的方法。
- 对于using声明，首选将其作用域设置为局部而不是全局。



# 九、对象和类

## 1.类

> 类是一种将**抽象**转换为**用户定义类型**的C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包。
>
> C++程序员将接口（类定义）放在头文件（.h）中，并将实现（类方法的代码）放在源代码文件（.cpp）中。

类规范的组成部分：

- 类声明：以数据成员的方式描述数据部分，以成员函数（被称为方法）的方式描述公有接口。

  - 内联方法：其定义位于类声明中的函数都将**自动**成为内联函数，类声明常将短小的成员函数作为内联函数

    > 内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。确保内联定义对多文件程序中的所有文件都可用的、最简便的方法是：将内联定义放在定义类的头文件中。（也可以定义在类声明之后，具体操作见第七章第一节）

```c++
class Stock
{
private:               //不必在类声明中使用关键字private，因为这是类对象的默认访问控制
	float mass;
	char name[20];
public:
	void update(double price);
	void Retort(void);
	...
};
//公有成员函数(public)是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。防止程序直接访问数据被称为数据隐藏(private).
```

- 类方法定义：描述如何实现类成员函数。
  - 定义成员函数时，使用**作用域解析运算符（::）**来标识函数所属的类；
  - 类方法可以访问类的private组件。

```c++
void Stock::uppdate(double price)    //函数头，update()函数是Stock类的成员
```

创建一个对象的方式与结构体相似:

```c++
Stock bozetta;
cout <<bozetta.Retort();        //使用成员运算符句点来调用（类）对象中的函数
```



## 2.类构造函数和析构函数

常规的初始化语法不适用于类，因此有了构造函数和析构函数。

注：**这两类函数都要在类中定义**。

> 构造函数

- 类构造函数，专门用于构造新对象、将值赋给它们的数据成员，但**不能通过对象来调用**。
- 构造函数没有声明类型。
- 构造函数的名称必须和类名称相同。

```c++
//声明和定义构造函数
原型：
Stock(const stirng & co,long n=0,double pr=0.0);    //没有返回类型！
```

--1-->使用构造函数：

```c++
//显式地调用构造函数
Stock food=Stock("World Cabbage",250,1.25);
//隐式地调用构造函数
Stock garment("World Cabbage",250,1.25);            //创建一个类并直接赋值
//上述二者等价
```



--2-->默认构造函数:

当且仅当**没有定义任何**构造函数时，编译器才会提供默认构造函数。



--3-->委托构造函数：

某个类型的一个构造函数可以委托同类型的另一个构造函数对对象进行初始化。

作用：避免你有多个参数表不同但是**逻辑相近**（或者有公共部分）的构造函数的时候，一个逻辑写好几遍造成代码重复。

```c++
class Person {
public:
    // 非委托构造函数使用对应的实参初始化成员
    Person(std::string _name, int _age, double _income):
        name(_name), age(_age), income(_income) { }
    // 其余构造函数全都委托给另一个构造函数
    Person(): Person("", 0, 0) {}
    Person(std::string _name): Person(mike,0,0) {}               //大括号里面可以有代码块
    Persona(std::string _name, int _age,): Person(mike,20,0){}   //不要加分号";"!!
};
```



--4-->复制构造函数(也叫拷贝构造函数)：

如果没有定义复制构造函数，那么编译器生成默认复制构造函数。默认的复制构造函数完成复制功能 。

```c++
//创建复制构造函数
class Point
{
	public:
		Point（int xx=0,int yy=0）          //构造函数
		{
			x=xx;y=yy;
		}
			
		Point (Point &p);                   //复制构造函数
		int getX(){return x;}
		int getY(){return y;}
	private:
		int x,y;
}
//复制构造函数的实现：
Point::Point (Point &p)
{
	x=p.x;
	y=p.y;
	cout <<"Calling the copy constructor"<<endl;
}
```



复制构造函数起作用的三种情况：(只有把对象**用值传递**时，才会调用复制构造函数；如果传递引用，则不会调用复制构造函数。因此，传递较大的对象时，**传递引用**的效率要比传值的效率**高**很多)

（1）当用一个对象去初始化同类的另一个对象时 

Point B=A;

（2）如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用

fun1(B);

（3）如果函数的返回值是类A的对象时,则函数返回时，A的复制构造函数被调用

Point fun2()

{	

```
	Point A(1,2);

	return A;	
```

}

B=fun2();



--5-->移动构造函数：(可以理解为快速的拷贝构造函数)

```c++
Myobject(Myobject&& other) noexcept     //noexcept必须加，告知编译器不会抛出异常
{
    other.data=nullptr;
}
```



移动赋值操作符（扩）：

```c++
类名&amp; operator=(类名&amp;&amp; other) noexcept
{
    if (this != &amp;other) {
        // 进行资源所有权的转移
    }
    return *this;
}
```



关于成员名和参数名：

- 不熟悉构造函数的您会试图将类成员名称用作构造函数的参数名

为避免这种混乱，解决方法如下：

1.一种常见的做法是在数据成员名中使用**m_前缀**

2.在成员名中使用**后缀_**





> 2.析构函数

用来完成对象被删除前的一些清理工作

```c++
~Clock(){}
```



## 3.this指针

一般来说，所有的类方法都将this指针设置为**调用它的对象的地址**。

如果希望成员函数对多个对象进行操作，可以将额外的对象作为参数传递给它。如果方法需要**显式**地引用调用它的对象，则可以使用this
指针。由于this指针被设置为调用对象的地址，因此*this是该对象的别名。



## 4.作用域为类的常量

在类中定义的名称（如类数据成员名和类成员函数名）的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可
知的。

为了解决常量在类中的生存问题：

- 第一种方式是在类中声明一个枚举。在类声明中声明的枚举的作用域为整个类
- C++提供了另一种在类中定义常量（必须是**整型常量**）的方式——使用关键字static(在**private**中使用)



## 5.class和struct的区别

> c++中，class和struct的区别:

-    成员访问权限->class的成员访问权限为private,而struct的成员访问权限为public
-    默认的继承方式->class的默认继承方式为private,而struct的默认继承方式为public

> struct在C和C++之间的区别

-    c中，struct是用户自定义数据类型，而c++中，struct是**抽象数据类型**，支持成员定义函数；
-    c中的struct是没有权限设置的，但是在c++中，给strcut添加了权限设置，增加了访问权限；
-    c中的struct只是变量的聚合体，可以封装数据，但是不可以隐藏，不可以定义函数成员；但是C++中的struct可以定义函数成员



## 6.静态成员函数

1.不属于对象：静态成员函数属于类本身，而不是类的具体对象。因此，静态成员函数不包含this指针，这意味着它们不能访问非静态成员变量或成员函数。
2.调用方式：静态成员函数可以通过类名直接调用，不需要创建类的实例。例如，ClassName::StaticMemberFunction();。
作用域：静态成员函数只能访问静态成员变量和其他静态成员函数。
3.存储方式：静态成员函数的代码只有一份，存储在可执行代码段中，与类的实例无关。
调用约定：由于静态成员函数不与对象实例关联，调用静态成员函数没有对象查找开销，更类似于普通函数调用。
4.线程和回调：由于静态成员函数中没有**this指针**，它们在线程和回调函数中有时会被用到，以避免名称冲突和简化线程管理。
声明和定义：静态成员函数的声明和使用static关键字，并且在类声明的内部或外部定义时，不需要使用static关键字。例如，static void foo(); 和 void CInteger::foo(){ printf("CInteger::foo()"); }。
5.限制：静态成员函数不能声明为const或volatile，也不能作为虚函数使用。
总结来说，静态成员函数是一种**特殊的类成员函数**，它们与类的实例无关，**只能访问静态成员**，并且可以通过类名直接调用。



# 十、使用类

## 1.运算符重载

不要返回指向局部变量或临时对象的引用。函数执行完毕后，局部变量和临时对象将消失，引用将指向不存在的数据。

```c++
operator op(argumenet-list)
Time operator+(const Time & t)const;     //重载加法运算符
```

>  当运算符重载为类的成员函数时，函数的参数个数比原来的操作数要少一个（后置单目运算符除外），这是因为成员函数用this指针隐式地访问了类的一个对象，它充当了运算符函数最左边的操作数。因此：
>
>  -  **双**目运算符重载为类的成员函数时，函数**只显式说明一个参数**，该形参是运算符的右操作数。
>  -  前置**单**目运算符重载为类的成员函数时，不需要显式说明参数，即函数**没有形参**。
>  -  后置**单**目运算符重载为类的成员函数时，函数要带有一个**整型形参**。

限制：

- 重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。
- 使用运算符时不能违反运算符原来的句法规则
- 不能创建新运算符。
- 不能重载下面的运算符
  - sizeof：sizeof运算符。
  - .：成员运算符。
  - . *：成员指针运算符。
  - ::：作用域解析运算符。
  - ?:：条件运算符。
  - typeid：一个RTTI运算符。
  - const_cast：强制类型转换运算符。
  - dynamic_cast：强制类型转换运算符。
  - reinterpret_cast：强制类型转换运算符。
  - static_cast：强制类型转换运算符。
- 表11.1中的大多数运算符都可以通过成员或非成员函数进行重载，但下面的运算符只能通过成员函数进行重载。
  - =：赋值运算符。
  - ( )：函数调用运算符。
  - [ ]：下标运算符。
  - ->：通过指针访问类成员的运算符。
  



### 1.1 重载<<运算符

```c++
ostream & operator<<(ostream & os,const c_name & obj)
{
	os<<...;
	return os;
}
//c_name是类名
//若重载>>运算符，则ostream应改为istream
```



### 1.2 构造函数使用new的类

- 对于指向的内存是由new分配的所有类成员，都应在**类的析构函数**中对其使用**delete**，该运算符将释放分配的内存。

- 如果析构函数通过对指针类成员使用delete来释放内存，则每个构造函数都应当使用new来初始化指针，或将它设置为空指针。
- 构造函数中要么使用new []，要么使用new，而不能混用。如果构造函数使用的是new[]，则析构函数应使用delete []；如果构造函数使用的是new，则析构函数应使用delete。
- 应定义一个**分配内存**（而不是将指针指向已有内存）的复制构造函数。这样程序将能够将类对象初始化为另一个类对象。这种构造函数的原型通常如下：

```
classname(const classname &)
```

- 应定义一个重载赋值运算符的类成员函数，其函数定义如下（其中c_pointer是c_name的类成员，类型为指向type_name的指针）。下面的示例假设使用new []来初始化变量c_pointer：

```
c_name & c_name::operator==(const c_name & cn)
{
	if(this==&cn)  //判断是否是自引用
	return *this;
	delete [] c_pointer;
	c_pointer=new type_name[size];
	...
	return *this;
}
```



### 1.3 前置/后置运算符

前置运算符要+&（如++i)，后置不加(如i++)



### 1.4有参构造函数和无参构造函数

有参构造函数：

```c++
//有参构造函数
Student(char* s="name")
{
	strcpy_S(m_name,s,"name");
}
```

无参构造函数：只负责为指针类型的成员变量分配内存，并赋值一个初始值，没有具体的赋值信息，该初始化只能为成员变量赋值一个默认值。

```c++
//无参构造函数
Student()
{
	m_name=(char*)malloc(100);
	if(m_name!=NULL)
	{
		strcpy_S(m_name,5,"name");
	}
	m_age=0;
}
```



## 2.友元函数

>  有一类特殊的非成员函数可以访问类的**私有**成员，它们被称为友元函数（友元函数**常**含有参数）。

```c++
friend Time void input(int i);
//time是类的名字
语法:
friend returnType functionname(arguments);

//定义(不要在定义中使用关键字friend！！！)
Time void input(int i)
{
	
}
```

注：

- 虽然该函数是在**类声明**中声明的，但它不是成员函数，因此不能使用成员运算符来调用；
- 虽然该函数不是成员函数，但它与成员函数的**访问权限相同**



## 3.关键字explicit

作用：关闭自动转换的特性

```c++
explicit Stonewt(double lbs);   //不允许隐式转换
```



## 4.转换函数

```c++
operator typeName();

如：
operator double();    //指出了要转换成的类型
```

- 转换函数必须是类方法；
- 转换函数**不能指定返回类型**；
- 转换函数不能有参数。



## 5.运行时类型识别(RTTI)

> RTTI只适用于包含虚函数的类



### 5.1 dynamic_cast运算符

> 语法:
>
> 是否可以安全地将对象的地址赋给特定类型的指针

```c++
Superb * pm=dynamic_cast<Superb *>(pg);   
//判断指针pg的类型是否可被安全地转换为Superb*。如果可以，运算符将返回对象的地址，否则返回一个空指针。

//将dynamic_cast用于引用
#include<typeinfo>
...
try{
	Superb & rs=dynamic_cast<Superb &>(rg);
	...
}
catch(bad_cast &)
{
	...
};
```



dynamic_cast执行基类向派生类的转换。

> 1.向下转型:将**基类**指针或引用转换为**派生**类指针或引用。这是 **dynamic_cast 最常见**的用途

```c++
class Base {};
class Derived : public Base {};

Base* basePtr = new Derived;
Derived* derivedPtr = dynamic_cast<Derived*>(basePtr); 
```



> 2.横向转型:在同一继承层级的**不同派生类**之间进行转换。

```c++
class Base {};
class Derived1 : public Base {};
class Derived2 : public Base {};

Base* basePtr = new Derived1;
Derived2* derived2Ptr = dynamic_cast<Derived2*>(basePtr); 
```



### 5.2 typeid运算符和type_info类

> typeid运算符使得能够确定两个对象是否为同种类型。

```c++
#include <typeinfo>
typeid(表达式)
typeid(类型说明符)
```

typeid运算符返回一个对type_info对象的引用，其中，type_info是在头文件typeinfo（以前为typeinfo.h）中定义的一个类。



### 5.3 类型转换运算符

> 提供更安全、更明确的类型转换

- dynamic_cast
- static_cast

static_cast运算符用于强迫隐式转换，例如将non-const对象转为const对象，或将int转为double等等。它也可以用来执行上述多种转换的反向转换，例如将void*指针转为typed指针，将pointer-to-base转为pointer-to-derived。但它无法将const转为non-const——这个只有const_cast才办得到。

- const_cast

const_cast运算符用于执行只有一种用途的类型转换，即改变值为const或volatile。

- reinterpret_cast.

reinterpret_cast运算符用于天生危险的类型转换。它不允许删除const，但会执行其他令人生厌的操作。有时程序员必须做一些依赖于实
现的、令人生厌的操作，使用reinterpret_cast运算符可以简化对这种行为的跟踪工作。



## 6.final和override说明符

final意味着该函数不能被覆盖

override意味着该函数应被覆盖



# 十一、类继承

## 1.简单的基类

> 从一个类派生出另一个类时，原始类称为基类，继承类称为**派生**类。

```c++
class Ratedplayer:public TableTennisPlayer
{
	//冒号指出RatedPlayer类的基类是TableTennisplayer类。
};
```

上述特殊的声明头表明TableTennisPlayer是一个公有基类，这被称为**公有派生**。派生类对象包含基类对象。使用公有派生，基类的公有成员将成为派生类的公有成员；基类的**私有**部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问。

- 继承的作用:
  - 派生类需要自己的构造函数
  - 派生类可以根据需要添加**额外**的数据成员和成员函数。



派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。例如，RatedPlayer构造函数不能直接设置继承的成员（firstname、lastname和hasTable），而必须使用基类的公有方法来访问私有的基类成员。具体地说，**派生类构造函数必须使用基类构造函数**。 



关于派生类**构造函数**：

- 首先创建基类对象；
- 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；
- 派生类构造函数应初始化派生类新增的数据成员。

> 创建派生类对象时，程序**首先调用基类构造函数**，然后**再调用派生类构造函数**。基类构造函数负责初始化继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。派生类的构造函数总是调用一个基类构造函数。可以使用初始化器列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。



关于派生类和基类之间的关系：

- 基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生类对象。

- 基类指针或引用只能用于调用基类方法

- 不可以将基类对象和地址赋给派生类引用和指针



## 2.成员初始化列表语法

```c++
ClassName::ClassName(parameters) : member1(value1), member2(value2), ..., memberN(valueN)
{
    // 构造函数体
    // 这里可以添加额外的初始化代码
}

ClassName 是类的名称。
parameters 是构造函数的参数。
member1(value1), member2(value2), ..., memberN(valueN) 是成员初始化列表。每个成员的初始化由成员名和相应的值组成，用逗号分隔。这里的值可以是参数、其他成员变量、或者直接指定的常量值。
构造函数体包含在花括号 {} 内，用于执行构造函数的实际操作。可以在构造函数体中进行其他初始化工作或执行必要的逻辑。

如：
RatedPlayer::RatedPlayer(unsigned int r,const TableTennisPlayer & tp):TableTennisPlayer(tp),rating(r)
{

}
```

该语法只能用于构造函数。

对于**本身就是类对象**的成员来说，使用成员初始化列表的效率更高。



## 3.多态公有继承

> C++有3种继承方式：公有继承、保护继承和私有继承
>
> 继承可以在基类的基础上**添加属性**，但**不能删除**基类的**属性**。
>
> 可以使用一个数组来表示多种类型的对象。这就是多态性。



公有继承建立一种**is-a**（is-a-kind-of）关系

**派生类和基类函数同名了，基类函数会被隐藏。**(在没有virtual的情况下)



实现多态公有继承的方法：

- 在派生类中重新定义基类的方法。

> 在派生类方法中，标准技术是使用**作用域解析运算符**来调用基类方法。若派生类没有重新定义某个**同名**函数，则不需要使用作用域解析运算符。

- 使用虚方法（经常在基类中将派生类会**重新定义**的方法声明为虚方法。）。

> 通过使用关键字virtual，如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法；如果使用了virtual，程序将根据引用或指针**指向的对象**的类型来选择方法。
>
> 如果基类中的析构函数不是虚析构（没有被virtual修饰），即使基类指针指向子类对象，析构的时候也不先调用子类的析构函数，而只调用基类的析构函数。
>
> 关键字virtual只用于类声明的方法原型中
>
> - 构造函数不能是虚函数。
> - 析构函数应当是虚函数，除非类不用做基类。
> - **通常应给基类提供一个虚析构函数**，即使它并不需要析构函数。
> - 友元不能是虚函数，因为友元不是类成员。



注意：

如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的。这样，程序将根据对象类型而不是引用或指针的类型来选择方法版本。**为基类声明一个虚析构函数也是一种惯例**。



## 4.静态联编和动态联编

> 指向基类的引用或指针可以引用派生类对象，而不必进行显式类型转换。
>
> 将派生类引用或指针转换为基类引用或指针被称为**向上强制转换**，这使公有继承不需要进行显式类型转换。
>
> 向上强制转换是可传递的。
>
> 将基类指针或引用转换为派生类指针或引用——称为**向下强制转换**。如果不使用显式类型转换，则向下强制转换是不允许的。原因是**is-a关系通常是不可逆的**。



## 5.访问控制:protected

> 派生类的成员可以**直接访问基类的保护成员**，但不能直接访问基类的私有成员。因此，对于外部世界来说，保护成员的行为与私有成员相似；但对于派生类来说，保护成员的行为与公有成员相似。

```c++
class Brass
{
protected:
	double balence;
...
}
```

最好对类数据成员采用**私有访问**控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据。



## 6.ABC抽象基类(纯虚函数)

> ABC描述的是至少使用一个**纯虚函数**的接口，从ABC派生出的类将根据派生类的具体特征，使用常规虚函数来实现这种接口。

纯虚函数声明的结尾处为=0，在原型中使用=0指出类是一个抽象基类，在类中可以不定义该函数。

```c++
virtual double Area()const=0;
```



# 十二、C++中的代码重用

## 1.valarray类

> 一个模板类，这个类用于**处理数值**（或具有类似特性的类），它支持诸如将数组中所有元素的值相加以及在数组中找出最大和最小的值等操作。

使用前提：包含头文件valarray

```c++
valarray<int>q_values;     //一个int类型的数组
valarray<double>weights;   //一个double类型的数组
```

包含的方法：

- operator ：让您能够访问各个元素。
- size( )：返回包含的元素数。
- sum( )：返回所有元素的总和。
- max( )：返回最大的元素。
- min( )：返回最小的元素。



## 2.各种继承方式

| 特征             | 公有继承             | 保护继承               | 私有继承             |
| ---------------- | -------------------- | ---------------------- | -------------------- |
| 公有成员变成     | 派生类的公有成员     | 派生类的保护成员       | 派生类的私有成员     |
| 保护成员变成     | 派生类的保护成员     | 派生类的保护成员       | 派生类的私有成员     |
| 私有成员变成     | 只能通过基类接口访问 | 只能通过基类接口访问   | 只能通过基类接口访问 |
| 能否隐式向上转换 | 是                   | 是（但只能在派生类中） | 否                   |



## 3.使用using重新定义访问权限

为使Student类可以使用valarray的operator方法，只需在Student类声明的公有部分包含下面的using声明:

```c++
using std::valarray<double>::operator[];
```



# 十三、输入、输出和文件

## 1.插入运算符<<

> <<叫作插入运算符，而不是左移运算符（左移运算符由于其外观（像向左流动的信息流）而获得这种新角色）。插入运算符被重载，使之能够识别C++中所有的基本类型：

- unsigned char；
- signed char；
- char；
- short；
- unsigned short；
- int；
- unsiged int；
- long；
- unsigned long；
- long long（C++11）；
- unsigned long long（C++11）；
- double;
- long double。



## 2.其他ostream方法

除了各种operator<<( )函数外，ostream类还提供了**put( )方法**和**write()方法**，前者用于显示字符，后者用于显示字符串。

```c++
cout.put(65);

const char *state2="Kansas";
for(int i=0;i<lenth;i++)
cout.write(state2,i);
```

> 刷新cout缓冲区

```c++
flush(cout);
//实际使用：
cout <<flush;
```



## 3.cout类相关成员函数

详见七-5



## 4.流状态

![QQ图片20240418203539](E:\代码笔记\笔记图片保存\QQ图片20240418203539.jpg)

![QQ图片20240418203545](E:\代码笔记\笔记图片保存\QQ图片20240418203545.jpg)



## 5.其他iostream方法

### 5.1 read()函数

> read( )函数读取指定数目的字节，并将它们存储在**指定的位置**中。

```c++
cin.read(gross,144);
```

与getline( )和get( )不同的是，read( )不会在输入后加上空值字符，因此不能将输入转换为字符串。read( )方法不是专为键盘输入设计的，它最常与ostream write( )函数结合使用，来完成文件输入和输出。该方法的返回类型为istream &，因此可以像下面这样将它拼接起来：

```c++
char gross[144];
char score[20];
cin.read(gross,144).read(score,20);
```

### 5.2 peek()函数

> peek( )函数**返回输入中的下一个字符**，但不抽取输入流中的字符。也就是说，它使得能够查看下一个字符。假设要读取输入，直到遇到换行符或句点，则可以用peek( )查看输入流中的下一个字符，以此来判断是否继续读取：

```c++
char great_input[80];
char ch;
int i=0;
while((ch=cin.peek())!='.' && ch!='\n')
	cin.get(great_input[i++]);
great_input[i]='\0';
```

cin.peek( )查看下一个输入字符，并将它赋给ch。然后，while循环的测试条件检查ch是否是句点或换行符。如果是，循环将该字符读入到数组中，并更新数组索引。当循环终止时，句点和换行符将留在输入流中，并作为接下来的输入操作读取的第一个字符。然后，代码将一个空值字符放在数组的最后，使之成为一个字符串。

### 5.3 gcount()方法

> gcount( )方法返回最后一个非格式化抽取方法读取的字符数。

这意味着字符是由get( )、getline( )、ignore( )或read( )方法读取的，不是由**抽取运算符**（>>）读取的，抽取运算符对输入进行格式化，使之与特定的数据类型匹配。例如，假设使用cin.get（myarray，80）将一行读入myarray数组中，并想知道读取了多少个字符，则可以使用strlen( )函数来计算数组中的字符数，这种方法比使用cin.gcount( )计算从输入流中读取了多少字符的速度要快。

### 5.4 putback()函数

> putback( )函数将一个字符**插入**到输入字符串中，被插入的字符将是下一条输入语句读取的第一个字符。

putback( )方法接受一个char参数——要插入的字符，其返回类型为istream &，这使得可以将该函数调用与其他istream方法拼接起来。使用peek( )的效果相当于先使用get( )读取一个字符，然后使用putback( )将该字符放回到输入流中。然而，putback( )允许将字符放到不是刚才读取的位置。



## 6.简单的文件I/O

> 文件模式：

文件的打开方式：
![0ded44668841a8db5c269cdd38ee57a6](E:\代码笔记\笔记图片保存\0ded44668841a8db5c269cdd38ee57a6.jpg)

![img](file:///C:\Users\wuqian\Documents\Tencent Files\3660692338\Image\C2C\0d516244d56692aa2e45c70a6a414d5d.jpg)



> 让程序写入文件的方法：
>
> 1．创建一个ofstream对象来管理输出流；
> 2．将该对象与特定的文件关联起来；
> 3．以使用cout的方式使用该对象，唯一的区别是输出将进入文件，而不是屏幕。

```c++
#include<fstream>       //首先包含头文件fstream
int main()
{
	ofstream fout;                 //fout是任意有效的C++名称
	fout.open("jar.txt");          //用fout进行文件的相关操作，这里是打开文件进行输出
	//ofstream fout("jar.txt");    //将上述两条语句合并成一条语句
	fout.close();                  //关闭文件
}
```



> 让程序读取文件的方法：
>
> 1.创建一个ifstream对象来管理输入流；
> 2.将该对象与特定的文件关联起来；
> 3.以使用cin的方式使用该对象。

```c++
#include<fstream>
int main()
{
	ifstream fin;
	fin.open("jar.txt");
	//ifstream fin("jar.txt");
	fin.close();
}
```



注：有些C++实现要求在该程序末尾使用fin.clear( )，有些则不要求，这取决于将文件与ifstream对象关联起来时，是否自动重置流状态。**使用fin.clear( )是无害的**，即使在不必使用它的时候使用。



## 7.文件模式

```c++
ofstream fout("bagels",ios_base::out | ios_base::app);
```

上述代码用**|**运算符来合并模式。



## 8.随机存取（seekg()和seekp()）

> 随机存取指的是直接移动（不是依次移动）到文件的任何位置。随机存取常被用于数据库文件，程序维护一个独立的索引文件，该文件指出数据在主数据文件中的位置。这样，程序便可以直接跳到这个位置，读取（还可能修改）其中的数据。如果文件由长度相同的记录组成，这种方法实现起来最简单。每条记录表示一组相关的数据。



在 C++ 中，有时需要从特定的位置开始读写文件，可以通过调用文件流对象的 seekp() 和 seekg() 成员函数来改变这个位置。

**文件输出流对象用 seekp() 函数**，**文件输入流对象用 seekg() 函数**，它们各有另个重载版本，语法格式如下：

```c++
istream& seekg (streampos pos);
istream& seekg (streamoff off, ios_base::seekdir way);

ostream& seekp (streampos pos);
ostream& seekp (streamoff off, ios_base::seekdir way);
```

参数 pos 表示文件中的绝对位置（从文件起始处开始计算），即移动到参数指定的位置。

参数 way 参数的值是一个枚举值，表示文件中的一些特殊位置，它的值有三种，分别是：
ios_base::beg：文件起始位置
ios_base::cur：文件当前位置
ios_base::end：文件结尾

参数 off 的值也是一个以字节为单位的整数，表示的是从 way 参数表示的位置处开始的偏移量，正数表示向前移动，负数表示向后移动。

当使用 fstream 对象时，可以用同一个流进行输入和输出操作，并使用 seekg() 和 seekp() 来控制读写指针的位置。下面是一个完整的示例，展示了如何使用 seekg() 和 seekp() 函数。



```c++
#include <iostream>
#include <fstream>
#include <string>
int main() {
  // 打开文件进行读写
  std::fstream file("example.txt", std::ios::in | std::ios::out | std::ios::app);
  if (!file) {
    std::cerr << "File cannot be opened!";
    return 1;
  }
  // 使用 seekp 设置写指针位置，并添加一行
  file.seekp(0, std::ios_base::end);
  file << "This is an appended line.\n";
  // 使用 seekg 设置读指针位置，然后读取一行
  std::string line;
  file.seekg(0, std::ios_base::beg); // 移到文件开始
  std::getline(file, line); // 读取第一行
  std::cout << "First Line: " << line << std::endl;
  // 使用 seekp 修改写指针位置，并更改一行内容
  // 假设我们知道第二行从第 25 个字节开始（这通常需要你先确定）
  file.seekp(25, std::ios_base::beg);
  file << "This is the modified second line.";
  // 使用 seekg 读取修改后的第二行内容
  file.seekg(25, std::ios_base::beg); // 移到第二行开始
  std::getline(file, line); // 读取第二行
  std::cout << "Modified Second Line: " << line << std::endl;
  // 关闭文件
  file.close();
  return 0;
}
```



示例中使用了 fstream 对象进行了读写操作。请注意以下几点：
用 seekp() 移动写指针并进行写入。
用 seekg() 移动读指针并进行读取。

总结

seekg() 和 seekp() 函数用于移动文件的读和写指针。其中，seekg() 主要用于输入流（istream），而 seekp() 主要用于输出流（ostream）。

注意，调用 seekg() 或 seekp() 之后，最好都检查是否成功，可以通过if (stream.fail())来进行检查。

此外，seekg() 和 seekp() 在文本模式下可能不会如预期工作，尤其是在 Windows 系统上，建议在打开文件时使用二进制模式（ios::binary）。

> **关于cerr：**
>
> std::cerr是ISO C++标准错误输出流，对应于ISO C标准库的stderr。
> 与std::cout不同，ISO C++要求当cerr被初始化后，cerr.flags() & unitbuf非零（保证流在每次输出操作后被刷新），且cerr.tie()返回&cout。 [1] 即cerr默认和cout同步但无缓冲。
>
> cerr与cout的区别
> cout对应于标准输出流，默认情况下是显示器。这是一个被缓冲的输出，可以被重定向。
> cerr对应标准错误流，用于显示错误消息。默认情况下被关联到标准输出流，但它不被缓冲，也就说错误消息可以直接发送到显示器，而无需等到缓冲区或者新的换行符时，才被显示。一般情况下不被重定向。
> 例如下面代码编译后生成test.exe
>
> ```c++
> // test.cpp
> #include <iostream>
> using namespace std;
> int main()
> {
> 	cout << "hello world—cout" << endl ;
> 	cerr << "hello world—cerr" << endl ;
> 	return 0;
> }
> ```
>
> 在命令行模式下键入下面的命令： 　
> test >>cout.txt
> 运行结果是：
> 在生成的cout.txt文件中输出了"hello world—cout" ，
> 同时在显示器上输出了"hello world—cerr" ，
> 也就是说cout的输出可以重定向到一个文件中，而cerr必须输出在显示器上。
>
> 为什么要用cerr?
> 比如，你的程序遇到调用栈用完了的威胁（无限，没有出口的递归）。
> 你说，你到什么地方借内存，存放你的错误信息？
> 所以有了cerr。其目的，就是在你最需要它的紧急情况下，还能得到输出功能的支持。 缓冲区的目的，就是减少刷屏的次数——比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子“同时”就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）。



## 9.使用临时文件

开发应用程序时，经常需要使用临时文件，这种文件的存在是短暂的，必须受程序控制。您是否考虑过，在C++中如何使用临时文件呢？创建临时文件、复制另一个文件的内容并删除文件其实都很简单。首先，需要为临时文件制定一个命名方案，但如何确保每个文件都被指定了独一无二的文件名呢？cstdio中声明的tmpnam( )标准函数可以帮助您。

```c++
char* tmpnam(char* pszName);      //原型
for(int i=0;i<10;i++)
{	
	tmpnam(pszName);                  //创建十个临时文件名
	cout <<pszName<<endl;
}

```

tmpnam( )函数创建一个临时文件名，将它放在pszName指向的C-风格字符串中。常量L_tmpnam和TMP_MAX（二者都是在cstdio中定义的）限制了文件名包含的字符数以及在确保当前目录中不生成重复文件名的情况下tmpnam( )可被调用的最多次数。



## 10.内核格式化

头文件sstream定义了一个从ostream类派生而来的ostringstream类（还有一个基于wostream的wostringstream类，这个类用于宽字符集）。如果创建了一个ostringstream对象，则可以将信息写入其中，它将存储这些信息。

格式化文本进入缓冲区，在需要的情况下，该对象将使用动态内存分配来增大缓冲区。



# 十四、友元、异常和其他

## 1.如何使用异常机制处理错误

> 1.三个组成部分

- 引发异常（使用关键字**throw**）
- 使用处理程序捕获异常（使用**catch**关键字）
- 使用try块

> 关键字noexcept

指出函数不会引发异常

```c++
double maxn() noexcept;
```



### 1.1 exception异常类

使用时需包含头文件exception，以下是以公有方式从exception类中派生而来的类



> 1 stdexcept类
>
> 使用时需包含头文件stdexcept
>
> 该类定义了logic_error和runtime_error类

- logic_error描述典型的逻辑错误，以此类推

每个类独有一个类似于logic_error的构造函数，让您能够提供一个供**方法what( )**返回的字符串。



### 1.2 bad_alloc异常和new

对于使用new导致的内存分配问题，C++的最新处理方式是让new引发bad_alloc异常。头文件new包含bad_alloc类的声明，它是从exception类公有派生而来的。



### 1.3空指针和new

很多代码都是在new在失败时返回空指针时编写的。为处理new的变化，有些编译器提供了一个标记（开关），让用户选择所需的行为。当前，C++标准提供了一种在失败时返回空指针的new，其用法如下：

```c++
int * pi=new(std::nothrow) int;
int * pa=new(std::nowthrow) int[500];
```



## 2.友元类和友元成员函数

> 友元成员函数

1.为了实现在Tv类中使用Remove的某个成员函数，需在定义Tv之前声明一个Tv，再将要使用的类定义在Tv前面。

2.为了在Remove中使用Tv的一个方法，可以使Remove中只包含方法声明，在后面再详细定义方法。

```c++
class Tv;        //前向声明
class Remove{...}
class Tv
{
	friend void Remote::set_chan(Tv & t,int c)
	...
}
```

> 友元类

```c++
class Tv
{
	friend class Remove;     //让整个类成为友元不需要前向声明
	...
}
```



## 3.嵌套类

> 作用域：

- 如果嵌套类是在另一个类的**私有部分**声明的，则只有后者知道它。

- 如果嵌套类是在另一个类的**保护部分**声明的，则它对于后者来说是可见的，但是对于外部世界则是不可见的。然而，在这种情况中，派生类将知道嵌套类，并可以直接创建这种类型的对象。

- 如果嵌套类是在另一个类的**公有部分**声明的，则允许后者、后者的派生类以及外部世界使用它，因为它是公有的。然而，由于嵌套类的作用域为包含它的类，因此在外部世界使用它时，必须使用类限定符。

> 访问控制

包含嵌套类的类都能使用该嵌套类，嵌套类可以访问被嵌套的类中的私有成员。



# 十五、改善程序与设计的55个做法

> 来自Effective C++

##  1.让自己习惯C++

- [ ] C++高效编程守则视状况而变化，取决于你使用C++的哪一部分
- [ ] 对于单纯常量，最好以const对象或enum替换#defines
- [ ] 对于形似函数的宏，最好改用inline函数替换#defines
- [ ] 将某些东西声明为const可帮助编译器侦测出错误方法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。
- [ ] 编译器强制实施bitwise constness，但你编写程序时应该使用“概念上的常量性”
- [ ] 当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。
- [ ] 为内置型对象进行手工初始化，因为C++不保证初始化它们。
- [ ] 构造函数最好使用成员初始列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。
- [ ] 为免除“跨编译单元之初始化次序”问题，请以local static 对象替换non-local static对象。

### 1.1 尽可能使用const

如果关键字const出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针自身是常量；如果出现在星号两边，表示被指物和指针两者都是常量

```c++
char greeting[]="Hello";
char *p=greeting;               //non-const pointer,non-const data
const char* p=greeting;         //non-const pointer,const data
char* const p=greeting;         //const pointer,non-const data
const char* const p=greeting;   //const pointer,const data
```



### 1.2 在迭代器中使用const

> 迭代器虽然不是元素本身，但它是引用元素的一种方式。

迭代器的作用像个T*指针

```c++
std::vector<int> vec;
...
const std::vector<int>::iterator iter=vec.begin();    //iter的作用像个T* const
*iter=10;        //正确的
++iter;          //错误的    

std::vector<int>::const_iterator cIter=vec.begin();   //cIter的作用像个const T*（常量迭代器）--不能修改其引用的元素的值
*cIter=10;       //错误的
++cIter;         //正确的
```

  

## 2.构造/析构/赋值运算

- [ ] 编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符，以及析构函数。
- [ ] 为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为private并且不予实现。使用像Uncopyable这样的base class也是一种做法。
- [ ] Polymorphic（带多态性质的）base classes 应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。
- [ ] Classes的设计目的如果不是作为base classes使用，或不是为了具备多态性（Polymorphically），就不该声明virtual析构函数。
- [ ] 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。
- [ ] 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。
- [ ] 在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class（比起当前执行构造函数和析构函数的那层）。
- [ ] 令赋值（assignment）操作符返回一个reference to *this。
- [ ] 确保当对象自我赋值时operator=有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap。
- [ ] 确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。
- [ ] Copying函数应该确保复制“对象内的所有成员变量”及所有base class 成分“。
- [ ] 不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中，并由两个copying函数共同调用。



## 3.资源管理

- [ ] 为防止资源泄漏，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。--以对象管理资源
- [ ] 两个常被使用的RAII classes分别是tr1::shared_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使它(被复制物)指向null。
- [ ] 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。
- [ ] 普遍而常见的RAII class copying行为是：抑制copying、施行引用计数法。不过其他行为也都可能被实现。
- [ ] APIs往往要求访问原始资源，所以每一个RAII class应该提供一个“取得其所管理之资源”的办法。
- [ ] 对原始资源的访问可能经由显示转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。

- [ ] 如果你在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。
- [ ] 以独立语句将newed对象存储于(置入)智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。



## 4.设计与声明

- [ ] 好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。
- [ ] “促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。
- [ ] “阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。
- [ ] tr1::shared_ptr支持定制型删除器。这可防范DLL问题，可被用来自动解除互斥锁（mutexes）。
- [ ] Class的设计就是type的设计。在定义一个新的type之前，请确定你已经考虑过本条款覆盖的所有讨论主题。
- [ ] 尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题。
- [ ] 上一条规则并不适用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value往往比较恰当。
- [ ] 绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。
- [ ] 切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允许约束条件获得保证，并提供class作者以充分的实现弹性。
- [ ] protected并不比public更具封装性。
- [ ] 宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包裹弹性和机能扩充性。
- [ ] 如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member。
- [ ] 当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。
- [ ] 如果你提供一个member swap，也该提供一个non-member swap用来调用前者。对于classes（而非templates），也请特化std::swap。
- [ ] 调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”。
- [ ] 为“用户定义类型”进行std template全特化是好的，但千万不要尝试在std内加入某些对std而言全新的东西。



## 5.实现

- [ ] 尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。

- [ ] 如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_casts。如果有个设计需要转型动作，试着发展无需转型的替代设计。

- [ ] 如果转型是必要的，试着将它隐藏在某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码内。

- [ ] 宁可使用C++style(新式)转型，不要使用旧式转型。前者容易辨识出来，而且也比较有着分门别类的职掌。

- [ ] 避免返回handles（包括references、指针、迭代器）指向对象内部。遵守这个条件可增加封装性，帮助const成员函数的行为像个const，并将发生“虚吊号码牌”（dangling handles）的可能性降至最低。

  
